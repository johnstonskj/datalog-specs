<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Datalog Specifications</title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
<link   rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.css"
        integrity="sha384-R4558gYOUz8mP9YWpZJjofhk+zx0AS11p36HnD2ZKj/6JR5z27gSSULCNHIRReVs"
        crossorigin="anonymous">
<script defer
        src="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.js"
        integrity="sha384-z1fJDqw8ZApjGO3/unPWUPsIymfsJmyrDVWC8Tv/a1HeOtGmkwNd/7xUS0Xcnvsx"
        crossorigin="anonymous"></script>
<script defer
        src="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/contrib/auto-render.min.js"
        integrity="sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR"
        crossorigin="anonymous"></script>

<script defer>
document.addEventListener("DOMContentLoaded", function() {
    renderMathInElement(document.body, {
        delimiters: [
            {left: "$$", right: "$$", display: true},
            {left: "\\(", right: "\\)", display: false},
            {left: "$", right: "$", display: false},
            {left: "\\[", right: "\\]", display: true}
        ]
    });
});
</script>

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="specs.css">
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="vnd_datalog_text/abstract.html"><strong aria-hidden="true">1.</strong> DATALOG-TEXT: Datalog Text Representation</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="vnd_datalog_text/introduction.html"><strong aria-hidden="true">1.1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="vnd_datalog_text/conformance.html"><strong aria-hidden="true">1.2.</strong> Conformance</a></li><li class="chapter-item expanded "><a href="vnd_datalog_text/basic_concepts.html"><strong aria-hidden="true">1.3.</strong> Basic Concepts</a></li><li class="chapter-item expanded "><a href="vnd_datalog_text/grammar.html"><strong aria-hidden="true">1.4.</strong> Datalog Text Grammar</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="vnd_datalog_text/grammar_program.html"><strong aria-hidden="true">1.4.1.</strong> Program</a></li><li class="chapter-item expanded "><a href="vnd_datalog_text/grammar_facts.html"><strong aria-hidden="true">1.4.2.</strong> Relations &amp; Facts</a></li><li class="chapter-item expanded "><a href="vnd_datalog_text/grammar_constants.html"><strong aria-hidden="true">1.4.3.</strong> Types &amp; Constants</a></li><li class="chapter-item expanded "><a href="vnd_datalog_text/grammar_rules.html"><strong aria-hidden="true">1.4.4.</strong> Rules</a></li><li class="chapter-item expanded "><a href="vnd_datalog_text/grammar_atoms.html"><strong aria-hidden="true">1.4.5.</strong> Atoms &amp; Terms</a></li><li class="chapter-item expanded "><a href="vnd_datalog_text/grammar_literals.html"><strong aria-hidden="true">1.4.6.</strong> Literals</a></li><li class="chapter-item expanded "><a href="vnd_datalog_text/grammar_queries.html"><strong aria-hidden="true">1.4.7.</strong> Queries</a></li><li class="chapter-item expanded "><a href="vnd_datalog_text/grammar_pi.html"><strong aria-hidden="true">1.4.8.</strong> Processing Instructions</a></li><li class="chapter-item expanded "><a href="vnd_datalog_text/grammar_comments.html"><strong aria-hidden="true">1.4.9.</strong> Comments</a></li><li class="chapter-item expanded "><a href="vnd_datalog_text/grammar_lexical.html"><strong aria-hidden="true">1.4.10.</strong> Terminal/Lexical</a></li></ol></li><li class="chapter-item expanded "><a href="vnd_datalog_text/resolvers.html"><strong aria-hidden="true">1.5.</strong> Resolvers</a></li><li class="chapter-item expanded "><a href="vnd_datalog_text/pragmas.html"><strong aria-hidden="true">1.6.</strong> Pragmas</a></li><li class="chapter-item expanded "><a href="vnd_datalog_text/errors.html"><strong aria-hidden="true">1.7.</strong> Errors</a></li><li class="chapter-item expanded "><a href="vnd_datalog_text/x_security.html"><strong aria-hidden="true">1.8.</strong> Security Considerations</a></li><li class="chapter-item expanded "><a href="vnd_datalog_text/x_international.html"><strong aria-hidden="true">1.9.</strong> Internationalization Considerations</a></li><li class="chapter-item expanded "><a href="vnd_datalog_text/x_ebnf.html"><strong aria-hidden="true">1.10.</strong> Appendix: EBNF</a></li><li class="chapter-item expanded "><a href="vnd_datalog_text/x_result_forms.html"><strong aria-hidden="true">1.11.</strong> Appendix: Result Formats</a></li><li class="chapter-item expanded "><a href="vnd_datalog_text/x_iana.html"><strong aria-hidden="true">1.12.</strong> Appendix: IANA Considerations</a></li><li class="chapter-item expanded "><a href="vnd_datalog_text/x_references.html"><strong aria-hidden="true">1.13.</strong> Appendix: References</a></li><li class="spacer"></li></ol></li><li class="chapter-item expanded "><a href="vnd_datalog_text/z_errata.html"><strong aria-hidden="true">2.</strong> Datalog Text Representation Errata</a></li><li class="chapter-item expanded "><a href="vnd_datalog_text/z_translations.html"><strong aria-hidden="true">3.</strong> Datalog Text Representation Translations</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Datalog Specifications</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/johnstonskj/datalog-specs" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="datalog-text-datalog-text-representation"><a class="header" href="#datalog-text-datalog-text-representation">DATALOG-TEXT: Datalog Text Representation</a></h1>
<h2 id="version-10-2-april-2022-draft"><a class="header" href="#version-10-2-april-2022-draft">Version: 1.0, 2 April 2022 (Draft)</a></h2>
<p><strong>Editor</strong>: Simon K. Johnston
&lt;<a href="mailto:johnstonskj@gmail.com">johnstonskj@gmail.com</a>&gt;</p>
<p>Please check the <a href="vnd_datalog_text/z_errata.html">§ Errata</a> for any errors or issues reported since publication.</p>
<p>The English version of this specification is the only normative version. Non-normative <a href="vnd_datalog_text/z_translations.html">§ Translations</a> may also be available.</p>
<hr />
<h2 id="abstract"><a class="header" href="#abstract">Abstract</a></h2>
<p>This document defines a standard textual representation of a Datalog program. This representation is based upon commonly used representations for programs and adds processing instructions and explicit Unicode support. The term <strong>DATALOG-TEXT</strong> SHALL BE used to reference this specification within this document and others that reference it.</p>
<h2 id="status-of-this-document"><a class="header" href="#status-of-this-document">Status of This Document</a></h2>
<p><em>This section describes the status of this document at the time of its
publication. Other documents may supersede this document.</em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p><em>This section is non-normative</em>.</p>
<p>Datalog is a logic programming language and a subset of the earlier Prolog<sup class="footnote-reference"><a href="#1">1</a></sup>. The language is interesting as it can be used as a data query language akin to SQL with some important additional capabilities such as recursive queries. It is also expressive enough to allow for its use as an entailment mechanism for ontology languages such as the Web Ontology Language (OWL)<sup class="footnote-reference"><a href="#2">2</a></sup> and the Semantic Web.</p>
<p>The specific language that may be represented by the DATALOG-TEXT grammar includes typed attributes and functional dependencies for relations, negated and arithmetic literals, disjunction in rule heads, and constraint rules. With the exception of required support for typed attributes the other <em>language features</em> are opt-in using <em>pragmas</em>.</p>
<h2 id="how-to-read-this-document"><a class="header" href="#how-to-read-this-document">How to Read This Document</a></h2>
<p><em>This section is non-normative.</em></p>
<p>This document is a detailed specification for DATALOG-TEXT, a representation in textual form, of a Datalog program. The document is primarily intended for the following audiences:</p>
<ul>
<li>Software developers who want to generate or consume Datalog programs, in the DATALOG-TEXT representation.</li>
<li>Software developers who want to convert existing Datalog serializations to DATALOG-TEXT.</li>
<li>Software developers who want to implement processors and APIs for DATALOG-TEXT.</li>
<li>Software developers who want to understand the design decisions and language syntax for DATALOG-TEXT.</li>
</ul>
<h2 id="contributing"><a class="header" href="#contributing">Contributing</a></h2>
<p><em>This section is non-normative.</em></p>
<p>The content for this site is generated from a <a href="https://github.com/johnstonskj/datalog-specs">GitHub repository</a>. Discussions, comments, and errata are hosted on the specification GitHub repository’s <a href="https://github.com/johnstonskj/datalog-specs/discussions">discussion section</a>.</p>
<h2 id="terminology"><a class="header" href="#terminology">Terminology</a></h2>
<p><em>This section is non-normative.</em></p>
<ul>
<li><strong>Media Type</strong> – This specification describes an Internet Media Type <span class="bibref inline"><a href="vnd_datalog_text/x_references.html#RFC1590">RFC1590</a></span> that is used “<em>in order to provide open and extensible data typing and type negotiation</em>” – from <span class="bibref inline"><a href="vnd_datalog_text/x_references.html#RFC2616">RFC2616</a>, section 3.7</span>.</li>
<li><strong>Program</strong> – A complete Datalog entity that may be serialized into a resource in a particular representation or media type.</li>
<li><strong>Representation</strong> – “<em>An entity included with a response that is subject to content negotiation, as described in section […]. There may exist multiple representations associated with a particular response status.</em>” – from <span class="bibref inline"><a href="vnd_datalog_text/x_references.html#RFC2616">RFC2616</a>, section 1.3</span>.</li>
<li><strong>Resource</strong> – “<em>A network data object or service that can be identified by a URI, as defined in section […]. Resources may be available in multiple representations (e.g. multiple languages, data formats, size, and resolutions) or vary in other ways.</em>” – from <span class="bibref inline"><a href="vnd_datalog_text/x_references.html#RFC2616">RFC2616</a>, section 1.3</span>.</li>
<li><strong>Dataset</strong> – An external resource that holds a representation of a Datalog resource.</li>
</ul>
<p>Using these terms this specification describes a particular <em>representation</em> of a Datalog <em>program</em>, whose type is identified by a unique <em>media type</em>, that may be serialized into a <em>resource</em> for storage or transfer.</p>
<p><img src="vnd_datalog_text/images/processor_terms.svg" alt="Processor Terms" /></p>
<ul>
<li><strong>Application</strong> – This denotes some software component that requires the ability to download, read, and act upon Datalog resources. To accomplish this the application has to interact with the <em>processor</em>.</li>
<li><strong>Processor</strong> – A software component that provides at least the <em>parser</em> and <em>resolver</em> and commonly the <em>evaluator</em> as well.
<ul>
<li><strong>Parser</strong> – The subcomponent that actually parses the resource, validating syntax and well-formedness rules (see <a href="vnd_datalog_text/grammar.html">§ Grammar</a> for the details of the DATALOG-TEXT language grammar).</li>
<li><strong>Resolver</strong> – The subcomponent that has to resolve and make available any referenced dataset resources (see <a href="vnd_datalog_text/resolvers.html">§ Resolvers</a> for details of the resolver).</li>
<li><strong>Evaluator</strong> – The subcomponent that consumes the parsed program and entails intensional facts from rules. </li>
</ul>
</li>
</ul>
<p>Using these terms this specification describes the requirements of the <em>parser</em> to correctly produce some representation of the program provided to it, and also the <em>resolver</em> requirements for retrieving external resources. </p>
<h2 id="datalog-naming-convention"><a class="header" href="#datalog-naming-convention">Datalog Naming Convention</a></h2>
<p>When we talk specifically about the Datalog language it is common to represent it in a roman serif face as
$\small\text{Datalog}$. This allows the distinction of talking in general about Datalog in the abstract vs. the actual
semantics of the language $\small\text{Datalog}$.</p>
<p>This core $\small\text{Datalog}$ language has many documented extensions that provide additional flexibility, conciseness, or
expressiveness. These <em>languages</em>, <em>sub-languages</em>, <em>extensions</em>, or <em>dialects</em> are usually labeled by adding a superscript
symbol that identifies the specific extension. For example, $\small\text{Datalog}^{\lnot}$ is
the language extended with negation of literals, $\small\text{Datalog}^{\Gamma}$ is the language
extended with type checking on attributes, and $\small\text{Datalog}^{\lnot,\theta}$ is the language
extended with negation of literals <em>and</em> arithmetic literals. The order of superscript symbols is
irrelevant.</p>
<table><thead><tr><th>Language</th><th>Introduces</th><th>Symbols</th></tr></thead><tbody>
<tr><td>$\small\text{Datalog}^{\lnot}$</td><td>negation of literals in rule bodies</td><td><code>!</code>, <code>NOT</code>, <code>￢</code></td></tr>
<tr><td>$\small\text{Datalog}^{\lor}$</td><td>disjunction in rule heads</td><td><code>;</code>, <code>OR</code>, <code>∨</code></td></tr>
<tr><td>$\small\text{Datalog}^{\Leftarrow}$</td><td>rules as constraints, i.e. no body</td><td>N/A</td></tr>
<tr><td>$\small\text{Datalog}^{\Gamma}$</td><td>typed attributes for relations</td><td>N/A</td></tr>
<tr><td>$\small\text{Datalog}^{\theta}$</td><td>arithmetic literals in rule bodies</td><td><code>=</code>, <code>!=</code>, <code>≠</code>, &lt;<code>, </code>&lt;=<code>, </code>≤<code>, </code>&gt;<code>, </code>&gt;=<code>, </code>≥<code>, </code>*=<code>, </code>≛`</td></tr>
<tr><td>$\small\text{Datalog}^{\rightarrow}$</td><td>functional dependency processing instruction</td><td><code>--&gt;</code>, <code>⟶</code></td></tr>
</tbody></table>
<p>When referring to the specifics of the language we will use the common format $\small\text{Datalog}$ with superscripts as necessary to identify specific language extensions being used. Note that the default language described by DATALOG-TEXT with no enabled language features is in fact $\small\text{Datalog}^{\Gamma}$ and not $\small\text{Datalog}$.</p>
<p>&nbsp;</p>
<hr />
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>Chapter 1 of <span class="bibref inline"><a href="vnd_datalog_text/x_references.html#CeGoTa90">CeGoTa90</a></span> provides a good overview of the drawbacks of Prolog and the advantages of Datalog for certain tasks.</p>
</div>
<div class="footnote-definition" id="2"><sup class="footnote-definition-label">2</sup>
<p>See <a href="https://www.w3.org/2001/sw/wiki/OWL/Implementations">https://www.w3.org/2001/sw/wiki/OWL/Implementations</a>.</p>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="conformance"><a class="header" href="#conformance">Conformance</a></h1>
<p>As well as sections marked as non-normative, all authoring guidelines, diagrams, examples, and notes in this specification are non-normative. Everything else in this specification is normative.</p>
<p>The keywords <em>MAY</em>, <em>MUST</em>, <em>MUST NOT</em>, <em>RECOMMENDED</em>, <em>SHOULD</em>, and <em>SHOULD NOT</em> in this document are to be interpreted as described in <a href="https://tools.ietf.org/html/bcp14">BCP 14</a> <span class="bibref inline"><a href="vnd_datalog_text/x_references.html#RFC2119">RFC2119</a></span> <span class="bibref inline"><a href="vnd_datalog_text/x_references.html#RFC8174">RFC8174</a></span> when, and only when, they appear in all capitals, as shown here.</p>
<p>A conforming DATALOG-TEXT <em>resource</em> is a Unicode string that MUST conform to the grammar and additional constraints defined in <a href="vnd_datalog_text/grammar.html">§ Datalog Text Grammar</a>, starting with the <code>program</code> production. </p>
<p>A conforming DATALOG-TEXT <em>parser</em> MUST ensure the resource it is provided is a conforming DATALOG-TEXT resource, signalling error conditions specified herein. Additionally, a conforming <em>resolver</em> MUST be able to convert paths to URIs <span class="bibref inline"><a href="vnd_datalog_text/x_references.html#RFC3986">RFC3986</a></span> and retrieve the identified resource on behalf of the parser.</p>
<h2 id="strict-vs-lax-processing"><a class="header" href="#strict-vs-lax-processing">Strict vs Lax Processing</a></h2>
<p>Two modes of operation for a conforming DATALOG-TEXT processor are described,
a <strong>strict</strong> processing mode that, while more verbose, relies less on
inference of a program’s semantics. For example, when strict processing is
enabled all relations both extensional and intensional MUST BE declared by
processing instructions. A <strong>lax</strong> processing mode allows more flexibility in
the source and is especially useful in dealing with Datalog written in
different dialects.</p>
<p>Strict processing support is RECOMMENDED, and may be enabled by the <a href="vnd_datalog_text/pragmas.html#pragma-strict"><code>strict</code> pragma</a>. Where behavior is required by strict processing it will be highlighted in the text. This specification does not define whether a conforming DATALOG-TEXT processor is required to be strict by default.</p>
<h2 id="media-type-and-content-encoding"><a class="header" href="#media-type-and-content-encoding">Media Type and Content Encoding</a></h2>
<p>The media type of DATALOG-TEXT resource is <code>application/vnd.datalog</code>. The content encoding of a DATALOG-TEXT document is always UTF-8. For complete details, see appendix <a href="vnd_datalog_text/x_iana.html">§ IANA Considerations</a>.</p>
<h3 id="features-parameter"><a class="header" href="#features-parameter"><code>features</code> Parameter</a></h3>
<p>This parameter is used to indicate the language features the resource requires. The list of supported feature identifiers is in <a href="vnd_datalog_text/conformance.html#language-features">§ Language Features</a>.</p>
<p>The content of this parameter is a comma separated list of feature identifiers. This is used as a hint to a conforming DATALOG-TEXT processor to determine if they can process the resource. </p>
<p>While it is clearly of benefit for the set of features listed in this parameter to be <strong>exactly</strong> the same as the set of language pragmas used in the document it is impossible to guarantee. Therefore, processors MAY choose to proceed parsing the resource or signal an error if they find that these feature lists do not match. </p>
<h4 id="errors"><a class="header" href="#errors">Errors</a></h4>
<ul>
<li><a href="vnd_datalog_text/errors.html#ERR_UNSUPPORTED_FEATURE"><code>ERR_UNSUPPORTED_FEATURE</code></a> – a feature identifier was not recognized, or supported, by the processor, even if it may be valid in some other version of this specification.</li>
</ul>
<h4 id="example"><a class="header" href="#example">Example</a></h4>
<p>The media type <code>application/vnd.datalog;features=negation,constraints</code> denotes a document with the following feature pragmas.</p>
<pre><code class="language-datalog">.pragma negation.
.pragma constraints.
</code></pre>
<h3 id="dialect-parameter"><a class="header" href="#dialect-parameter"><code>dialect</code> Parameter</a></h3>
<p>This parameter is used to indicate the language dialect the resource conforms to. The list of supported dialect identifiers is in <a href="vnd_datalog_text/conformance.html#dialect-identifiers">§ Dialect Identifiers</a>.</p>
<p>The content of this parameter is a single dialect identifier.</p>
<h4 id="errors-1"><a class="header" href="#errors-1">Errors</a></h4>
<ul>
<li><code>ERR_UNSUPPORTED_DIALECT</code> – a dialog identifier was not recognized, or supported, by the processor, even if it may be valid in some other version of this specification.</li>
</ul>
<h2 id="language-features"><a class="header" href="#language-features">Language Features</a></h2>
<p>As mentioned in the <a href="vnd_datalog_text/introduction.html">introduction</a> the language described by DATALOG-TEXT with no additional language features enabled is $\small\text{Datalog}^{\Gamma}$, the language $\small\text{Datalog}$ with typed relation attributes. All the language features defined in this specification MUST BE supported by a conforming DATALOG-TEXT processor. These features are: <code>arithmetic_literals</code>, <code>constraints</code>, <code>disjunction</code>, <code>extended_numerics</code>, <code>functional_dependencies</code>, and <code>negation</code>.</p>
<table><thead><tr><th>Identifier</th><th>Source</th><th>Date</th></tr></thead><tbody>
<tr><td><code>arithmetic_literals</code></td><td>This specification</td><td>XX March 2022</td></tr>
<tr><td><code>constraints</code></td><td>This specification</td><td>XX March 2022</td></tr>
<tr><td><code>disjunction</code></td><td>This specification</td><td>XX March 2022</td></tr>
<tr><td><code>extended_numerics</code></td><td>This specification</td><td>XX March 2022</td></tr>
<tr><td><code>negation</code></td><td>This specification</td><td>XX March 2022</td></tr>
</tbody></table>
<p>This specification DOES NOT cover the behavior of a DATALOG-TEXT evaluator and
so support of these language features only ensures that a DATALOG-TEXT
resource can be parsed and validated, not that it can be evaluated. In the
case that an evaluator detects a language feature it cannot support it MUST
signal the error <a href="vnd_datalog_text/errors.html#ERR_UNSUPPORTED_FEATURE"><code>ERR_UNSUPPORTED_FEATURE</code></a>.</p>
<h2 id="dialect-identifiers"><a class="header" href="#dialect-identifiers">Dialect Identifiers</a></h2>
<p>The purpose of this parameter is to allow for the identification of Datalog
representations that are produced by applications that are not DATALOG-TEXT
conformant. These applications may use an alternate syntax for grammar
specified by DATALOG-TEXT, or they may extend the language with non-standard 
features. </p>
<table><thead><tr><th>Identifier</th><th>Source</th><th>Date</th></tr></thead><tbody>
<tr><td><code>core</code> (default)</td><td>This specification</td><td>XX March 2022</td></tr>
<tr><td><code>mitre</code></td><td>MITRE Datalog <a href="http://datalog.sourceforge.net/">implementation</a></td><td>01 June 2016 (v2.6)</td></tr>
</tbody></table>
<h3 id="mitre-datalog"><a class="header" href="#mitre-datalog">MITRE Datalog</a></h3>
<p>This dialect only allows ASCII, Prolog style, operators; <code>:-</code> for material
implication, <code>,</code> for conjunction, and <code>!</code> for negation. The dialect does not
support the features <code>constraints</code>, <code>disjunction</code>, or <code>extended_numerics</code>.</p>
<p>The use of other syntaxed defined in this specification MUST signal the error
<a href="vnd_datalog_text/errors.html#ERR_UNSUPPORTED_SYNTAX"><code>ERR_UNSUPPORTED_SYNTAX</code></a>.</p>
<h3 id="example-1"><a class="header" href="#example-1">Example</a></h3>
<p>Note that the absence of the <code>dialect</code> parameter on the MIME type is the same
as using the value <code>core</code>. The following values are therefore equivalent.</p>
<pre><code class="language-text">application/vnd.datalog
application/vnd.datalog;dialect=core
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="basic-concepts"><a class="header" href="#basic-concepts">Basic Concepts</a></h1>
<p><em>This section is non-normative.</em></p>
<p>The following graph is an informal representation of the DATALOG-TEXT grammar. It represents_leaf values_ (constants, variables, …) in rectangles and <em>composite values</em> as ellipses. Additionally, where a composite is defined as $\small A \oplus B$ a small filled diamond shape represents the exclusive or relationship. Finally, some edges in the graph are labeled with “<code>*</code>”, “<code>+</code>”, and “<code>?</code>” which are the common cardinality notation used in regular expressions and BNF notation.</p>
<p><a href="vnd_datalog_text/images/abstract_graph.svg"><img src="vnd_datalog_text/images/abstract_graph.svg" alt="Abstract Graph" /></a></p>
<div class="caption figure">Abstract Graph View (click to expand)</div>
<p><strong>Notes</strong></p>
<ol>
<li>The edge between <em>rule</em> and <em>head</em> has the label “<code>?/*</code>” as it has differing cardinality under $\small\text{Datalog}$, $\small\text{Datalog}^{\lor}$, and $\small\text{Datalog}^{\Leftarrow}$.</li>
<li>The edge between <em>literal</em> and <em>negated?</em> is labeled as “<code>?</code>” as it is necessary under $\small\text{Datalog}^{\lnot}$ but not under $\small\text{Datalog}$.</li>
<li>The edge from the choice between <em>literal</em> and <em>comparison</em> is labeled as “<code>?</code>” as it is necessary under
$\small\text{Datalog}^{\theta}$ but not under $\small\text{Datalog}$.</li>
<li>The three dashed lines represent the following constraints.
<ol>
<li>Between <em>rule</em> and <em>relation</em> to represent the fact that intensional relations are inferred from rule evaluation.</li>
<li>Between <em>relation</em> and <em>predicate</em> to represent the fact that the predicate for a relation may be derived from the predicate of the <em>atoms</em> within it (or vice versa).</li>
<li>Between <em>head</em> and <em>body</em> to represent the fact that while both are optional for a <em>rule</em>, one or other must be present.</li>
</ol>
</li>
</ol>
<h2 id="brief-summary-of-concepts"><a class="header" href="#brief-summary-of-concepts">Brief Summary of Concepts</a></h2>
<p><em>This section is non-normative.</em></p>
<h3 id="program"><a class="header" href="#program">Program</a></h3>
<p>A $\small\text{Datalog}$ program $\small P$ is a tuple comprising the extensional <em>database</em>, EDB, or  $\small D_{E}$, the intensional <em>database</em>, IDB, or  $\small D_{I}$, and a set of <strong><a href="vnd_datalog_text/basic_concepts.html#queries">queries</a></strong> $\small Q$.</p>
<p>$$\small P=(D_{E}, D_{I}, Q)$$</p>
<p>The extensional database is a set of (extensional-) <strong><a href="vnd_datalog_text/basic_concepts.html#relations">relations</a></strong>.</p>
<p>The intensional database is a set of <strong><a href="vnd_datalog_text/basic_concepts.html#rules">rules</a></strong>, $\small\Lambda$, for constructing additional (intensional-) <strong><a href="vnd_datalog_text/basic_concepts.html#relations">relations</a></strong>.</p>
<p>Relations $\small R$ and rules $\small\lambda$ are built from a language $\small \mathcal{L}$,</p>
<p>$$\small \mathcal{L}=( \mathcal{C},\mathcal{P},\mathcal{V},\Gamma)$$</p>
<ul>
<li>$\small \mathcal{C}$ – the finite sets of symbols for all constant values; e.g. <code>hello</code>, <code>&quot;hi&quot;</code>,
<code>123</code>,</li>
<li>$\small \mathcal{P}$ – predicates, the finite set of alphanumeric character strings that begin with a
lowercase character; e.g. <code>human</code>, <code>size</code>, <code>a</code>,</li>
<li>$\small \mathcal{V}$ – variables, the finite set of alphanumeric character strings that begin with an
uppercase character; e.g. <code>X</code>, <code>A</code>, <code>Var</code>.</li>
<li>$\small \Gamma$ – a finite set of data <strong><a href="vnd_datalog_text/basic_concepts.html#types">types</a></strong> – introduced by the language $\small\text{Datalog}^{\Gamma}$.</li>
</ul>
<h3 id="relations"><a class="header" href="#relations">Relations</a></h3>
<p>A relation is a tuple comprising a unique label $\small \mathcal{p}$, a <strong><a href="vnd_datalog_text/basic_concepts.html#schema">schema</a></strong> $\small S$, and a <em>set</em> of <strong><a href="vnd_datalog_text/basic_concepts.html#facts">facts</a></strong> $\small F$.</p>
<p>$$R = (\mathcal{p}, S, F)$$</p>
<p>Relation labels are <em>predicates</em> $\mathcal{p}\in\mathcal{P}$.</p>
<h3 id="schema"><a class="header" href="#schema">Schema</a></h3>
<p>A relation’s schema $\small S$ is a tuple that describes the attributes $\small(\alpha_1,\ldots,\alpha_j)$ that make up the relation. Each attribute is a tuple of type and optional label, $\small\alpha_i=(\gamma_i, \mathcal{p}_i^?)$ where attribute types are taken from a set of types $\small\Gamma$ such that $\small\gamma_i\in\Gamma$ and $\small \mathcal{p}_i^?\in\mathcal{P}$.</p>
<p>$$\small S = (\alpha_1,\ldots,\small \small \alpha_j)$$</p>
<p>$$\small \alpha = (\gamma, \mathcal{p}^?)$$</p>
<p>$$\small \forall \alpha \in S(\gamma_{\alpha}\in\Gamma \land \mathcal{p}^?_{\alpha}\in\mathcal{P})$$</p>
<p>A relation’s schema in $\small\text{Datalog}^{\rightarrow}$ is extended to support <strong><a href="vnd_datalog_text/basic_concepts.html#functional-dependencies">functional dependencies</a></strong>.</p>
<p>$$\small S = ((\alpha_1,\ldots, \alpha_j), \lbrace \varphi_1, \ldots, \varphi_k\rbrace )$$</p>
<h3 id="types"><a class="header" href="#types">Types</a></h3>
<p>Commonly Datalog supports the simple types <em>boolean</em> $\small\mathbb{B}$, <em>integers</em> $\small\mathbb{Z}$, and <em>symbols</em> $\small\mathcal{K}$. General character <em>strings</em> may also be added, $\small\mathcal{S}$.</p>
<p>$$\small\Gamma = \lbrace \mathbb{B}, \mathbb{Z}, \mathcal{K}, \mathcal{S} \rbrace$$</p>
<p>All constant values have a type in the types for the current language.</p>
<p>$$\small\gamma(c) \in \Gamma$$</p>
<h3 id="facts"><a class="header" href="#facts">Facts</a></h3>
<p>A fact is an <strong><a href="vnd_datalog_text/basic_concepts.html#atoms">atom</a></strong> where all <strong><a href="vnd_datalog_text/basic_concepts.html#terms">terms</a></strong> are constant values $\small t \in \mathcal{C}$, not variables. </p>
<p>$$\small \forall t \in A (t \in \mathcal{C})$$</p>
<h3 id="atoms"><a class="header" href="#atoms">Atoms</a></h3>
<p>An atom is a predicate-labeled tuple of label and <strong><a href="vnd_datalog_text/basic_concepts.html#terms">terms</a></strong>. The atom’s label $\small\mathcal{p}\in\mathcal{P}$ identifies the relation to which it belongs. </p>
<p>$$\small A=(\mathcal{p},(t_1,\ldots,t_j))$$</p>
<p>Each term $\small t_i$ MUST conform to the relation’s schema attribute $\small \alpha_i$.</p>
<p>$$\small\forall i \in [1,j] (\Gamma \vdash \gamma(t_i) : \gamma_{\alpha_i})$$</p>
<h3 id="terms"><a class="header" href="#terms">Terms</a></h3>
<p>A term is either a constant value $\small c\in\mathcal{C}$, or a variable $\small v\in\mathcal{V}$.</p>
<p>$$\small \forall t \in A (t \in \mathcal{C} \lor t \in \mathcal{V})$$</p>
<h3 id="rules"><a class="header" href="#rules">Rules</a></h3>
<p>A rule takes the form <code>IF antecedence THEN consequence</code> where the consequence is the head of the rule before the material implication symbol and the antecedence is the body of the rule after the material implication symbol.</p>
<p>The consequence, or head, of the rule $\small\lambda\in\Lambda$ is the disjunction of atoms $\small A_1 \ldots, A_m \subseteq D_I$ and the antecedence, or body, of the rule is the conjunction of <strong><a href="vnd_datalog_text/basic_concepts.html#literals">literals</a></strong> $\small L_1, \ldots, L_n$.</p>
<p>$$\lambda=\small A_1, \lor \ldots, \lor A_m \leftarrow L_1, \land \ldots, \land L_n$$</p>
<ul>
<li>In $\small\text{Datalog}$ only a single atom MUST be present in the head; $\small m=1$.</li>
<li>In $\small\text{Datalog}^{\lor}$ one or more atoms MAY be present in the head; $\small m \geq 1$.</li>
<li>In $\small\text{Datalog}^{\Leftarrow}$ a single atom MAY or MAY NOT be present in the head; $\small m \leq 1$.</li>
</ul>
<h3 id="literals"><a class="header" href="#literals">Literals</a></h3>
<p>A literal is either <strong>relation</strong> or <strong><a href="vnd_datalog_text/basic_concepts.html#arithmetic-literals">arithmetic</a></strong>, $\small L^{\theta}$ and may be <strong><a href="vnd_datalog_text/basic_concepts.html#negated-literals">negated</a></strong>. Relational literals are simply an atom:</p>
<p>$$\small L=A \in D_E \cup D_I$$</p>
<h3 id="negated-literals"><a class="header" href="#negated-literals">Negated Literals</a></h3>
<p>Negated literals are present only in $\small\text{Datalog}^{\lnot}$.</p>
<p>A literal may be positive $\small L$ or negative $\small \lnot L$.</p>
<p>$$L^{\prime} = L \oplus \lnot L$$</p>
<h3 id="arithmetic-literals"><a class="header" href="#arithmetic-literals">Arithmetic Literals</a></h3>
<p>Arithmetic literals are present only in $\small\text{Datalog}^{\theta}$.</p>
<p>An arithmetic literal takes the form of a tuple where $\small t_{lhs}$ and $\small t_{rhs}$ are terms and $\small\theta$ is a binary comparison operation (equal, less-than, etc.).</p>
<p>$$\small L^{\theta} = (t_{lhs}, \theta, t_{rhs})$$</p>
<p>$$\small L^{\theta^{\prime}} = L^{\theta} \oplus \lnot L^{\theta}$$</p>
<h3 id="queries"><a class="header" href="#queries">Queries</a></h3>
<p>A query $\small q \in Q$ is an atom which acts as a goal and returns any facts that match its terms.</p>
<p>$$\small q=A \in D_E \cup D_I$$</p>
<h3 id="functional-dependencies"><a class="header" href="#functional-dependencies">Functional Dependencies</a></h3>
<p>Functional dependencies are present only in $\small\text{Datalog}^{\rightarrow}$.</p>
<p>A functional dependency, $\small\varphi$, is a uniqueness constraint for a relation of the form $\small R: \alpha \longrightarrow \beta$ with the set $\small\alpha$ or determinant and the set $\small\beta$ or dependent of attributes where the attributes exist in the relation and the two sets are not equal.</p>
<p>$$\small\varphi = (R, \alpha, \beta)$$</p>
<p>$$\small \alpha, \beta \subseteq S_R \land \alpha\neq\beta$$</p>
<p>This relationship denotes that for the relation $\small R$, every valid combination of determinant values uniquely determines the value of the dependent values.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="datalog-text-grammar"><a class="header" href="#datalog-text-grammar">Datalog Text Grammar</a></h1>
<p>A DATALOG-TEXT resource is a Unicode<span class="bibref inline"><a href="vnd_datalog_text/x_references.html#UNICODE">UNICODE</a></span> character string encoded in UTF-8. Unicode code points only in the range <code>U+0</code> to <code>U+10FFFF</code> inclusive are allowed.</p>
<p><strong>White space</strong> (Unicode category <strong>Zs</strong>, tab <code>U+0009</code> and <code>EOL</code>) is used to separate two terminals which would otherwise be (mis-)recognized as one terminal. White space is significant in the production <code>literal-string</code> (see <a href="vnd_datalog_text/grammar_constants.html">§ Types &amp; Constants</a>).</p>
<p><strong>Comments</strong> in a DATALOG-TEXT resource takes either of the following forms. Comments are treated as white space.</p>
<ol>
<li>Begin with a <code>%</code> and continue to the end of line (<code>EOL</code>) or end of file if there is no end of line after the comment marker. </li>
<li>Begin with the characters <code>/*</code> and end with the characters <code>*/</code>. They may occur anywhere outside other tokens, and their contents have no influence on the rendering. Comments MAY NOT be nested.</li>
</ol>
<p>The EBNF used here is defined in XML 1.0 <span class="bibref inline"><a href="vnd_datalog_text/x_references.html#EBNF-NOTATION">EBNF-NOTATION</a></span> with the addition that each rule in the grammar ends with a semicolon character <code>;</code>. The amended rule for <code>symbol</code> is shown below.</p>
<pre><code class="language-ebnf">symbol ::= expression &quot;;&quot;
</code></pre>
<p>The following are the detailed sections of the grammar.</p>
<ul>
<li><a href="vnd_datalog_text/grammar_program.html">Program</a></li>
<li><a href="vnd_datalog_text/grammar_facts.html">Relations &amp; Facts</a></li>
<li><a href="vnd_datalog_text/grammar_constants.html">Types &amp; Constants</a></li>
<li><a href="vnd_datalog_text/grammar_rules.html">Rules</a></li>
<li><a href="vnd_datalog_text/grammar_atoms.html">Atoms &amp; Terms</a></li>
<li><a href="vnd_datalog_text/grammar_literals.html">Literals</a></li>
<li><a href="vnd_datalog_text/grammar_queries.html">Queries</a></li>
<li><a href="vnd_datalog_text/grammar_pi.html">Processing Instructions</a></li>
<li><a href="vnd_datalog_text/grammar_comments.html">Comments</a></li>
<li><a href="vnd_datalog_text/grammar_lexical.html">Terminal/Lexical</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="program-1"><a class="header" href="#program-1">Program</a></h1>
<p>A Datalog program consists of a set of facts that comprise the extensional database, a list of rules that are used to infer relations in the intensional database, and possibly a set of queries to interrogate the result of any reasoning performed over the program.</p>
<p>To be able to facilitate interchange a DATALOG-TEXT resource also includes
<em>processing instructions</em> that provide the parser and resolver information on
how to interpret the contents of the resource<sup class="footnote-reference"><a href="#1">1</a></sup>.</p>
<p><img src="vnd_datalog_text/images/program.png" alt="program" /></p>
<pre><code class="language-ebnf">program ::= processing-instruction* ( fact | rule | query )* ;
</code></pre>
<p>A program consists of a single file containing facts, rules, and queries as well as any additional files referenced via <a href="vnd_datalog_text/grammar_pi.html">§ Processing Instructions</a>.</p>
<h2 id="example-2"><a class="header" href="#example-2">Example</a></h2>
<p>The following program is an encoding of the classical syllogism “<em>all men are mortal, Socrates is a man, therefore Socrates is mortal</em>” <span class="bibref inline"><a href="vnd_datalog_text/x_references.html#Mill1851">Mill1851</a></span>.</p>
<pre><code class="language-datalog">1: .assert human(string).
2: .infer mortal from human.
3: 
4: human(socrates).
5: 
6: mortal(X) :- human(X).
7: 
8: ?- mortal(socrates).
</code></pre>
<ul>
<li>Lines 1-2 define two relations, an extensional relation named <em>human</em> and an intensional relation named <em>mortal</em>. Each relation schema comprises a single, unlabeled, string attribute.</li>
<li>Line 4 makes the assertion that Socrates is human.</li>
<li>Line 6 is the rule that any human is also therefore mortal.</li>
<li>Line 8 is a query that effectively asks <em>is there a fact in the mortal relation where the attribute is “socrates”?</em>.</li>
</ul>
<p>The outcome of this will be of the form:</p>
<pre><code class="language-text">+------------+
| _: boolean |
+============+
| true       |
+------------+
</code></pre>
<p>&nbsp;</p>
<hr />
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>Syntax diagrams are generated by <a href="https://www.bottlecaps.de/rr/ui">bottlecaps.de</a>.</p>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="relations--facts"><a class="header" href="#relations--facts">Relations &amp; Facts</a></h1>
<p>While relations are a key aspect of the Datalog language there is no actual
production for relation in the syntax. This is because the syntax instead
expects a set of facts expressed and where those facts share the same label,
and are <em>schema compatible</em> they comprise a relation. Each relation has a
schema that defines the number of attributes, their types, and optionally
their labels. The number of attributes is often termed the <em>arity</em> of the
relation or of a fact.</p>
<blockquote>
<p>In some literature, where Datalog is analyzed from a <em>model theoretic</em> view,
the term <strong>sort</strong> is more often used than <strong>schema</strong>. In either case the
meaning is equivalent. See <span class="bibref
inline"><a href="vnd_datalog_text/x_references.html#Wilfred97">Wilfred97</a></span> and 
<span class="bibref inline"><a href="vnd_datalog_text/x_references.html#AbHuVi94">AbHuVi94</a></span>.</p>
</blockquote>
<p>Facts may be either <em>asserted</em> (added to a relation), or <em>retracted</em> (removed
from a relation).</p>
<p><img src="vnd_datalog_text/images/fact.png" alt="fact" /></p>
<pre><code class="language-ebnf">fact    ::= assertion | retraction ;
</code></pre>
<p>Assertion is denoted by a fact body followed by the perion, <code>'.'</code> character.</p>
<p><img src="vnd_datalog_text/images/assertion.png" alt="fact" /></p>
<pre><code class="language-ebnf">assertion
        ::= fact-body &quot;.&quot; ;
</code></pre>
<p>Retraction is denoted by a fact body followed by the tilde, <code>'~'</code> character.
As a relation is a set of facts, each fact is syntactically unique and
addition and removal are based on the equality relation for each constant type.</p>
<p><img src="vnd_datalog_text/images/retraction.png" alt="fact" /></p>
<pre><code class="language-ebnf">retraction
        ::= fact-body &quot;~&quot; ;
</code></pre>
<p>Retraction of a fact which is not a member of the relation MUST NOT be treated
as an error, although it MAY BE handled with a warning or informational message.</p>
<p>The body of a fact is expressed in the form of ground
<a href="vnd_datalog_text/grammar_atoms.html">§ Atoms</a> where all
<a href="vnd_datalog_text/grammar_atoms.html#terms">§ Terms</a> are constant, and so they have a
specific production rather than a constrained form of the <code>atom</code> rule. A
predicate is the identifying label shared by a relation and its facts.</p>
<p><img src="vnd_datalog_text/images/fact-body.png" alt="fact" /></p>
<pre><code class="language-ebnf">fact-body
        ::= predicate ( &quot;(&quot; constant ( &quot;,&quot; constant )* &quot;)&quot; )? ;
</code></pre>
<p>A predicate is a string of characters that MUST start with a character from
the Unicode category <strong>Ll</strong>.</p>
<p><img src="vnd_datalog_text/images/predicate.png" alt="predicate" /></p>
<pre><code class="language-ebnf">predicate
        ::= LC_ALPHA ( ALPHA | DIGIT | UNDERSCORE )* ;
</code></pre>
<h2 id="errors-2"><a class="header" href="#errors-2">Errors</a></h2>
<p>Attempting to add a fact that is schema incompatible with an explicitly
declared extensional relation MUST signal the error <a href="vnd_datalog_text/errors.html#ERR_INCONSISTENT_FACT_SCHEMA"><code>ERR_INCONSISTENT_FACT_SCHEMA</code></a>.</p>
<pre><code class="language-datalog">.assert human(string).

human(22).
%% ==&gt; ERR_INCONSISTENT_FACT_SCHEMA
</code></pre>
<p>It is an error to add a fact that is schema incompatible with an implicitly inferred extensional relation. In this case the first occurrence of <code>human</code> had a string value and so a relation was inferred with a single string attribute.</p>
<pre><code class="language-datalog">human(socrates).
human(22).
%% ==&gt; ERR_INCONSISTENT_FACT_SCHEMA
</code></pre>
<p>Some cases may not be so obvious, especially with numerics. The value <code>22</code> is inferred to be <code>integer</code>, the value <code>22.0</code> is inferred to be a <code>decimal</code>, and the value <code>22.0e2</code> is inferred to be a <code>float</code>. Therefore, the example below causes an error.</p>
<pre><code class="language-datalog">human(22).      % integer
human(22.0).    % decimal
human(22.0e+2). % float
%% ==&gt; ERR_INCONSISTENT_FACT_SCHEMA
</code></pre>
<p>It is also an error to assert facts where the label identifies an intensional, rather than extensional relation.</p>
<pre><code class="language-datalog">.assert human(string).
.infer mortal from human.

mortal(22).
%% ==&gt; ERR_PREDICATE_NOT_AN_EXTENSIONAL_RELATION
</code></pre>
<p>In this final example the error is caused by processing in strict mode where all relations MUST be declared via processing instructions before use.</p>
<pre><code class="language-datalog">.pragma strict.

human(socrates).
%% ==&gt; ERR_PREDICATE_NOT_AN_EXTENSIONAL_RELATION
</code></pre>
<h2 id="examples"><a class="header" href="#examples">Examples</a></h2>
<p>The following demonstrates a simple fact denoting that the constant <code>brooke</code> representing some
individual is the parent of some individual represented by the constant <code>&quot;Xerces&quot;</code>.</p>
<pre><code class="language-datalog">parent(&quot;Xerces&quot;, brooke).
</code></pre>
<p>In a graph program an edge can be represented as an edge with a source vertex, target vertex, and weight.</p>
<pre><code class="language-datalog">edge(src, tgt, 100).
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="types--constants"><a class="header" href="#types--constants">Types &amp; Constants</a></h1>
<p>Constants are supported in three types, String, Numbers, and Boolean. Whereas some definitions of
Datalog introduce an additional Identifier type, ASDI treats these as <em>short strings</em> that can
safely be expressed without quotes; therefore, the values <code>xerces</code> and <code>&quot;xerces&quot;</code> are equivalent.</p>
<p><img src="vnd_datalog_text/images/constant.png" alt="constant" /></p>
<pre><code class="language-ebnf">constant
        ::= string | number | boolean ;
</code></pre>
<h2 id="strings"><a class="header" href="#strings">Strings</a></h2>
<p>Strings are described in both the identifier and quoted form in the <code>string</code> rule.</p>
<p>Strings MUST NOT contain characters from the Unicode category <strong>Cc</strong> (Control) except <code>#x09</code> tab, <code>#x0A</code> line feed, and <code>#x0D</code> carriage return.
Additionally, strings MUST NOT contain characters from the Unicode categories <strong>Cf</strong> (format), <strong>Co</strong> (Private Use), or <strong>Cs</strong> (Surrogate). 
These characters and any other non-printable characters MUST be included using the escape format: <code>\&quot;</code>, <code>\t</code>, <code>\n</code>, <code>\r</code>, <code>\u{XXXX}</code>, or <code>\u{XXXXXXXX}</code>. </p>
<p><img src="vnd_datalog_text/images/string.png" alt="string" /></p>
<pre><code class="language-ebnf">string  ::= identifier-string | literal-string ;
</code></pre>
<p>An <code>identifier-string</code> is a string of characters that looks much like a predicate <code>hello</code>, or a <em>namespaced</em> predicate <code>message:hello</code>. This allows for simple string values to be specified without quoting, and a syntax that is closer to the original Prolog form. The introduction of the “:” and trailing string part is an addition in DATALOG-TEXT that allows for larger programs to naturally introduce namespaces for symbols.</p>
<blockquote>
<p>In some Datalog literature and implementations there is a <code>symbol</code> type with a similar grammar production to <code>predicate</code>. In some implementations a symbol type is supported, but it’s <em>value</em> is the string representation of the predicate. This can lead to API confusion here a symbol can be created but is manipulated as a string. </p>
</blockquote>
<p><img src="vnd_datalog_text/images/identifier-string.png" alt="identifier-string" /></p>
<pre><code class="language-ebnf">identifier-string
        ::= predicate ( &quot;:&quot; ALPHA ( ALPHA | DIGIT | UNDERSCORE )* )? ;
</code></pre>
<p>Literal strings are enclosed in double quote characters <code>'&quot;'</code> and use the backslash escaping for quotes <code>\&quot;</code>, tab <code>\t</code>, new-line <code>\n</code>, and carriage return <code>\r</code>.</p>
<p><img src="vnd_datalog_text/images/literal-string.png" alt="literal-string" /></p>
<pre><code class="language-ebnf">literal-string
        ::= DQUOTE ( string-escape | [^#x22] )* DQUOTE ;
</code></pre>
<p>The escape form also allows for the escaping of Unicode characters either in 4 or 8 character hexadecimal format.</p>
<p><img src="vnd_datalog_text/images/string-escape.png" alt="string-escape" /></p>
<pre><code class="language-ebnf">string-escape
        ::= &quot;\\&quot; ( DQUOTE | [tnr] )
        | &quot;\u{&quot; HEXDIGIT HEXDIGIT HEXDIGIT HEXDIGIT
              ( HEXDIGIT HEXDIGIT HEXDIGIT HEXDIGIT )? &quot;}&quot; ;
</code></pre>
<h3 id="errors-3"><a class="header" href="#errors-3">Errors</a></h3>
<ul>
<li><a href="vnd_datalog_text/errors.html#ERR_INVALID_VALUE_FOR_TYPE"><code>ERR_INVALID_VALUE_FOR_TYPE</code></a> – invalid characters present within a string value.</li>
</ul>
<h2 id="numbers"><a class="header" href="#numbers">Numbers</a></h2>
<p>A conforming DATALOG-TEXT processor MUST provide the data type <code>integer</code>, and MAY provide the data types <code>decimal</code> and <code>float</code> if the feature <code>extended_numerics</code> is enabled. Any use of these types when the corresponding feature is not enabled should signal the error <code>ERR_FEATURE_NOT_ENABLED</code>.</p>
<p><img src="vnd_datalog_text/images/number.png" alt="number" /></p>
<pre><code class="language-ebnf">number  ::= float   # Optional
        | decimal   # Optional
        | integer ; # Required
</code></pre>
<h3 id="integers"><a class="header" href="#integers">Integers</a></h3>
<p>While this specification does not require a specific number of bits for integer values a conforming DATALOG-TEXT processor MUST provide <em>at least</em> 64-bit signed values $\small -2^{64} &lt; v &lt; 2^{64}$. </p>
<p><img src="vnd_datalog_text/images/integer.png" alt="integer" /></p>
<pre><code class="language-ebnf">integer ::= ( &quot;+&quot; | &quot;-&quot; )? DIGIT+
</code></pre>
<h3 id="fixed-point-decimals"><a class="header" href="#fixed-point-decimals">Fixed-Point Decimals</a></h3>
<p>Fixed-Point Decimal values MUST BE a 128-bit representation of a fixed-precision decimal number. The finite set of values of type <code>decimal</code> are of the form $\small m / 10^e$, where $\small m$ is an integer such that $\small -2^{96} &lt; m &lt; 2^{96}$, and $\small e$ is an integer between $\small 0$ and $\small 28$ inclusive. </p>
<p><img src="vnd_datalog_text/images/decimal.png" alt="decimal" /></p>
<pre><code class="language-ebnf">decimal ::= integer &quot;.&quot; DIGIT+
</code></pre>
<h3 id="floating-point"><a class="header" href="#floating-point">Floating-Point</a></h3>
<p>DATALOG-TEXT floating point values are patterned after the <span class="bibref inline"><a href="vnd_datalog_text/x_references.html#XMLSCHEMA-2">XMLSCHEMA-2</a></span> <code>double</code> type which in turn is patterned on the  IEEE double-precision 64-bit floating point type <span class="bibref inline"><a href="vnd_datalog_text/x_references.html#IEEE754">IEEE754</a></span>. </p>
<blockquote>
<p>From <span class="bibref inline"><a href="vnd_datalog_text/x_references.html#XMLSCHEMA-2">XMLSCHEMA-2</a></span>:</p>
<p><em>This datatype differs from that of <span class="bibref inline"><a href="vnd_datalog_text/x_references.html#IEEE754">IEEE754</a></span> in that there is only one NaN and only one zero. This makes the equality and ordering of values in the data space differ from that of <span class="bibref inline"><a href="vnd_datalog_text/x_references.html#IEEE754">IEEE754</a></span> only in that for schema purposes</em> <code>NaN = NaN</code>.</p>
</blockquote>
<p>The DATALOG-TEXT production uses the <span class="bibref inline"><a href="vnd_datalog_text/x_references.html#R7RS">R7RS</a></span> Scheme notation for infinities and not-a-number.</p>
<p><img src="vnd_datalog_text/images/float.png" alt="float" /></p>
<pre><code class="language-ebnf">float   ::= ( decimal ( &quot;e&quot; | &quot;E&quot; ) integer )
            | &quot;+inf.0&quot; 
            | &quot;-inf.0&quot; 
            | &quot;+nan.0&quot; ;
</code></pre>
<h3 id="errors-4"><a class="header" href="#errors-4">Errors</a></h3>
<ul>
<li><a href="vnd_datalog_text/errors.html#ERR_INVALID_VALUE_FOR_TYPE"><code>ERR_INVALID_VALUE_FOR_TYPE</code></a> – a constant value is too large for the implementation type.</li>
</ul>
<h3 id="examples-1"><a class="header" href="#examples-1">Examples</a></h3>
<pre><code class="language-datalog">age(plato, 2400.0). %% ==&gt; ERR_FEATURE_NOT_ENABLED
</code></pre>
<pre><code class="language-datalog">.pragma extended_numerics.

age(plato, 2400.0).
</code></pre>
<h2 id="booleans"><a class="header" href="#booleans">Booleans</a></h2>
<p>Boolean values are represented simply as either <code>true</code> or <code>false</code>.</p>
<p><img src="vnd_datalog_text/images/boolean.png" alt="boolean" /></p>
<pre><code class="language-ebnf">boolean ::= &quot;true&quot; | &quot;false&quot; ;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rules-1"><a class="header" href="#rules-1">Rules</a></h1>
<p>As <a href="vnd_datalog_text/grammar_facts.html">§ Facts</a> are syntactically distinct from rules in DATALOG-TEXT  there is no need for empty bodies – all rules MUST have at least one literal. Material implication may be written using the Unicode character <code>⟵</code> (U+27F5: long leftwards arrow).</p>
<p><img src="vnd_datalog_text/images/rule.png" alt="rule" /></p>
<pre><code class="language-ebnf">rule    ::= head? ( &quot;:-&quot; | &quot;&lt;-&quot; | &quot;⟵&quot; ) body &quot;.&quot; ;
</code></pre>
<p>The following sets of rules are equivalent.</p>
<pre><code class="language-datalog">ancestor(X, Y) :- parent(X, Y).
ancestor(X, Y) &lt;- parent(X, Y).
ancestor(X, Y) ⟵ parent(X, Y).
</code></pre>
<h2 id="rule-head"><a class="header" href="#rule-head">Rule Head</a></h2>
<p>The head of a rule MUST conform to one of the following:</p>
<ul>
<li>In the language $\small\text{Datalog}$ a single <a href="vnd_datalog_text/grammar_atoms.html">§ Atom</a>.</li>
<li>In the language $\small\text{Datalog}^{\lor}$ a disjunction of one or more <a href="vnd_datalog_text/grammar_atoms.html">§ Atom</a>.</li>
<li>In the language $\small\text{Datalog}^{\Leftarrow}$ nothing, or syntactically the value <code>&quot;⊥&quot;</code>.</li>
</ul>
<p><img src="vnd_datalog_text/images/head.png" alt="head" /></p>
<pre><code class="language-ebnf">head    ::= ( atom ( ( &quot;;&quot; | &quot;|&quot; | &quot;OR&quot; | &quot;∨&quot; ) atom )* )
            | &quot;⊥&quot; ;
</code></pre>
<h3 id="errors-5"><a class="header" href="#errors-5">Errors</a></h3>
<ul>
<li><a href="vnd_datalog_text/errors.html#ERR_EXTENSIONAL_RELATION_IN_RULE_HEAD"><code>ERR_EXTENSIONAL_RELATION_IN_RULE_HEAD</code></a>
–  an extensional relation is used in the head of a rule. </li>
</ul>
<pre><code class="language-datalog">parent(&quot;Xerces&quot;, brooke).

parent(X,Y) :- father(X,Y).
%% ==&gt; ERR_EXTENSIONAL_RELATION_IN_RULE_HEAD
</code></pre>
<h3 id="disjunction"><a class="header" href="#disjunction">Disjunction</a></h3>
<p>The language feature <code>disjunction</code> (enabled by the <a href="vnd_datalog_text/pragmas.html#pragma-disjunction-feature">§ Pragma disjunction</a>) corresponds to the language $\small\text{Datalog}^{\lor}$ and allows multiple atoms to appear in the rule’s head with the semantics that these are choices. This syntax will not be accepted unless the feature is enabled.</p>
<p>The following describes the rule that <em>if X is a parent then X is <strong>either</strong> a father <strong>or</strong> mother</em>.</p>
<pre><code class="language-datalog">.pragma disjunction.

father(X) ;  mother(X) :- parent(X).
father(X) |  mother(X) :- parent(X).
father(X) OR mother(X) :- parent(X).
father(X) ⋁  mother(X) :- parent(X).
</code></pre>
<p>As the use of disjunction in this position in the head is <em>inclusive</em> it is considered that any rule as above can be transformed into the following standard form. Clearly, in this case this is not the expected semantics which would require an <em>exclusive disjunction</em>, the language $\small\text{Datalog}^{\oplus}$. This specification does not support exclusive disjunction.</p>
<pre><code class="language-datalog">father(X) :- parent(X).
mother(X) :- parent(X).
</code></pre>
<h3 id="constraints"><a class="header" href="#constraints">Constraints</a></h3>
<p>The language feature <code>constraints</code> (enabled by the <a href="vnd_datalog_text/pragmas.html#pragma-constraints-feature">§ Pragma constraints</a>) corresponds to the language $\small\text{Datalog}^{\Leftarrow}$ and allows the specification of rules with no head. In this case the material implication symbol is REQUIRED, the falsity symbol MAY be used for readability.</p>
<p>The following sets of rules are equivalent.</p>
<pre><code class="language-datalog">.pragma constraints.

:- alive(X) AND dead(X).
⊥ ⟵ alive(X) ∧ dead(X).
</code></pre>
<h2 id="rule-body"><a class="header" href="#rule-body">Rule Body</a></h2>
<p>The body of a rule is a conjunction of one, or more, <a href="vnd_datalog_text/grammar_literals.html">§ Literals</a>.</p>
<p><img src="vnd_datalog_text/images/body.png" alt="body" /></p>
<pre><code class="language-ebnf">body    ::= literal ( ( &quot;,&quot; | &quot;&amp;&quot; | &quot;AND&quot; | &quot;∧&quot; ) literal )* ;
</code></pre>
<p>The following sets of rules are equivalent.</p>
<pre><code class="language-datalog">movie_star(X) :- star(X)  ,  movie_cast_member(X, _, _).
movie_star(X) :- star(X)  &amp;  movie_cast_member(X, _, _).
movie_star(X) :- star(X) AND movie_cast_member(X, _, _).
movie_star(X) :- star(X)  ∧  movie_cast_member(X, _, _).
</code></pre>
<h2 id="errors---safety"><a class="header" href="#errors---safety">Errors - Safety</a></h2>
<p>A DATALOG-TEXT processor MUST disallow the creation or addition of rules that are <em>unsafe</em>. These are rule forms that typically introduce infinite sets that cannot be reasoned over.</p>
<ul>
<li><a href="vnd_datalog_text/errors.html#ERR_HEAD_VARIABLE_NOT_IN_POSITIVE_RELATIONAL_LITERAL"><code>ERR_HEAD_VARIABLE_NOT_IN_POSITIVE_RELATIONAL_LITERAL</code></a>
All variables used in the head of a rule MUST appear in a positive relational literal.</li>
</ul>
<pre><code class="language-datalog">...
a(X) :- b(Y).
%% ==&gt; ERR_HEAD_VARIABLE_NOT_IN_POSITIVE_RELATIONAL_LITERAL
</code></pre>
<ul>
<li><a href="vnd_datalog_text/errors.html#ERR_NEGATIVE_VARIABLE_NOT_IN_POSITIVE_RELATIONAL_LITERAL"><code>ERR_NEGATIVE_VARIABLE_NOT_IN_POSITIVE_RELATIONAL_LITERAL</code></a>
All variables used in a negated literal MUST appear in a positive relational literal.</li>
</ul>
<pre><code class="language-datalog">.pragma negation.
...
a(X) :- b(Y), NOT b(X).
%% ==&gt; ERR_NEGATIVE_VARIABLE_NOT_IN_POSITIVE_RELATIONAL_LITERAL
</code></pre>
<ul>
<li><a href="vnd_datalog_text/errors.html#ERR_ARITHMETIC_VARIABLE_NOT_IN_POSITIVE_RELATIONAL_LITERAL"><code>ERR_ARITHMETIC_VARIABLE_NOT_IN_POSITIVE_RELATIONAL_LITERAL</code></a>
All variables used in an arithmetic literal MUST appear in a positive relational literal.</li>
</ul>
<pre><code class="language-datalog">.pragma arithmetic_literals.
...
a(X) :- b(Y), X &lt; Y.
%% ==&gt; ERR_ARITHMETIC_VARIABLE_NOT_IN_POSITIVE_RELATIONAL_LITERAL
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="atoms--terms"><a class="header" href="#atoms--terms">Atoms &amp; Terms</a></h1>
<p>A term is a labeled tuple of terms and is either a <em>fact</em> or a <em>goal</em>/<em>sub-goal</em>.</p>
<p>In the case of a fact the label identifies the relation to which it belongs and all terms must be constant values – also termed a <em>ground</em> atom. Facts may belong to either extensional or intensional relations.</p>
<p>In the case of a goal it is the consequence of a rule. Its goal is satisfied if the antecedents, now termed sub-goals, are satisfied. </p>
<p><img src="vnd_datalog_text/images/atom.png" alt="atom" /></p>
<pre><code class="language-ebnf">atom    ::= predicate &quot;(&quot; term ( &quot;,&quot; term )* &quot;)&quot; ;
</code></pre>
<h2 id="terms-1"><a class="header" href="#terms-1">Terms</a></h2>
<p>A term within an atom is simply either a constant value (string, number, boolean) or a variable.</p>
<p><img src="vnd_datalog_text/images/term.png" alt="term" /></p>
<pre><code class="language-ebnf">term    ::= variable | constant ;
</code></pre>
<h2 id="variables"><a class="header" href="#variables">Variables</a></h2>
<p>Note that we explicitly separate variables into named and anonymous forms here.</p>
<p><img src="vnd_datalog_text/images/variable.png" alt="variable" /></p>
<pre><code class="language-ebnf">variable
        ::= named-variable | anon-variable ;
</code></pre>
<p>A named variable is a string of characters that MUST start with a character from the Unicode category <strong>Lu</strong>. An anonymous variable is represented simply by a single underscore <code>&quot;_&quot;</code> character.</p>
<p><img src="vnd_datalog_text/images/named-variable.png" alt="named-variable" /></p>
<pre><code class="language-ebnf">named-variable
        ::= UC_ALPHA ( ALPHA | DIGIT | UNDERSCORE )* ;
        
anon-variable
        ::= UNDERSCORE ;
</code></pre>
<h2 id="examples-2"><a class="header" href="#examples-2">Examples</a></h2>
<p>The following are all valid atoms.</p>
<pre><code class="language-datalog">dead(julius_caesar).
emperor(julius_caesar, rome).
date(1997, 02, 26).
emperor(X, Y).
emperor(X, rome).
emperor(X, _).
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="literals-1"><a class="header" href="#literals-1">Literals</a></h1>
<p>Any valid atom is also a valid <em>positive relational</em> literal. The syntax below also allows for <em>negative</em> literals as well as arithmetic expressions as literals. Conjunction may be written with the Unicode character <code>∧</code> (U+2227: logical and ).</p>
<p><img src="vnd_datalog_text/images/literal.png" alt="literal" /></p>
<pre><code class="language-ebnf">literal ::= ( &quot;!&quot; | &quot;NOT&quot; | &quot;￢&quot; )?
            ( relational-literal 
            | arithmetic-literal ) ;
</code></pre>
<p><img src="vnd_datalog_text/images/relational-literal.png" alt="relational-literal" /></p>
<pre><code class="language-ebnf">relational-literal
        ::= atom ;
</code></pre>
<h2 id="examples-3"><a class="header" href="#examples-3">Examples</a></h2>
<p>The following rules are all equivalent.</p>
<pre><code class="language-datalog">ancestor(X, Y) ⟵ parent(X, Z)  ,  ancestor(Z, Y).
ancestor(X, Y) ⟵ parent(X, Z)  &amp;  ancestor(Z, Y).
ancestor(X, Y) ⟵ parent(X, Z)  ∧  ancestor(Z, Y).
ancestor(X, Y) ⟵ parent(X, Z) AND ancestor(Z, Y).
</code></pre>
<h2 id="negation"><a class="header" href="#negation">Negation</a></h2>
<p>The language feature <code>negation</code> corresponds to the language $\small\text{Datalog}^{\lnot}$ and
allows the specification of negated literals. Negation may also be written using the Unicode
character <code>￢</code> (U+FFE2: full-width not sign). The following rules are equivalent.</p>
<pre><code class="language-datalog">.pragma negation.

alive(X) :- person(X), NOT dead(X).
alive(X) ⟵ person(X) ∧ ￢dead(X).
</code></pre>
<h3 id="errors-6"><a class="header" href="#errors-6">Errors</a></h3>
<ul>
<li><a href="vnd_datalog_text/errors.html#%60ERR_NEGATIVE_VARIABLE_NOT_IN_POSITIVE_RELATIONAL_LITERAL%60"><code>ERR_NEGATIVE_VARIABLE_NOT_IN_POSITIVE_RELATIONAL_LITERAL</code></a>
– the negated rule is not considered safe.</li>
</ul>
<pre><code class="language-datalog">.pragma negation.

alive(X) :- NOT dead(X).
alive(X) ⟵ ￢dead(X).
</code></pre>
<h2 id="arithmetic-literals-1"><a class="header" href="#arithmetic-literals-1">Arithmetic Literals</a></h2>
<p>The language feature <code>comparisons</code> corresponds to the language $\small\text{Datalog}^{\theta}$ and
allows the use of arithmetic literals. Comparisons take place between two literals and are
currently limited to a set of common operators. Note the addition of a string match operator, this
is similar to the Perl <code>=~</code> and requires a string value/variable on the left and a string value or
variable on the right that compiles to a valid Rust regular expression.
Finally, the rule <code>named-term</code> disallows the use of anonymous variables in
arithmetic literals.</p>
<p><img src="vnd_datalog_text/images/arithmetic-literal.png" alt="arithmetic-literal" /></p>
<pre><code class="language-ebnf">arithmetic-literal
        ::= operand operator operand ;
</code></pre>
<p><img src="vnd_datalog_text/images/operand.png" alt="operand" /></p>
<pre><code class="language-ebnf">operand ::= ( named-variable | constant ) ;
</code></pre>
<p><img src="vnd_datalog_text/images/operator.png" alt="operator" /></p>
<pre><code class="language-ebnf">operator
        ::= &quot;=&quot;
            | (&quot;!=&quot; | &quot;/=&quot; | &quot;≠&quot;)
            | &quot;&lt;&quot;
            | (&quot;&lt;=&quot; | &quot;≤&quot;)
            | &quot;&gt;&quot;
            | (&quot;&gt;=&quot; | &quot;≥&quot;)
            | (&quot;*=&quot; | &quot;≛&quot; | &quot;MATCHES&quot;) ;
</code></pre>
<p>The Unicode characters <code>≠</code> (not equal to <code>\u{2260}</code>), <code>≤</code> (less-than or equal to <code>\u{2264}</code>),
<code>≥</code> (greater-than or equal to <code>\u{2265}</code>, and star equals <code>\u{e2899b}</code>) may be substituted for the
common arithmetic and string operators.</p>
<p>All arithmetic operations <strong>must</strong> be between terms of the some type, such that the property
<em>compatible</em> introduce above is defined as:</p>
<p>$$\tag{xvi}\small compatible(\tau_{lhs}, \tau_{rhs}, \theta) \leftarrow \tau_{lhs} = \tau_{rhs}$$</p>
<p>Additionally, some operators are not present for all types, as shown in the table below.</p>
<table><thead><tr><th>Type</th><th><code>=</code>, <code>≠</code></th><th><code>&lt;</code>, <code>≤</code>, <code>&gt;</code>, <code>≥</code></th><th><code>≛</code></th></tr></thead><tbody>
<tr><td>String</td><td>Yes</td><td>Yes - lexical</td><td>Yes</td></tr>
<tr><td>Integer</td><td>Yes</td><td>Yes</td><td>No</td></tr>
<tr><td>Decimal</td><td>Yes</td><td>Yes</td><td>No</td></tr>
<tr><td>Float</td><td>Yes</td><td>Yes</td><td>No</td></tr>
<tr><td>Boolean</td><td>Yes</td><td>No</td><td>No</td></tr>
</tbody></table>
<h3 id="errors-7"><a class="header" href="#errors-7">Errors</a></h3>
<ul>
<li><a href="vnd_datalog_text/errors.html#ERR_INCOMPATIBLE_TYPES_FOR_OPERATOR"><code>ERR_INCOMPATIBLE_TYPES_FOR_OPERATOR</code></a> – the two operands have different types; for example <code>1 &lt; true</code>.</li>
<li><a href="vnd_datalog_text/errors.html#ERR_INVALID_OPERATOR_FOR_TYPE"><code>ERR_INVALID_OPERATOR_FOR_TYPE</code></a> – the operator is not supported by one, or both, operands <code>22 *= false</code>.</li>
</ul>
<h3 id="example-3"><a class="header" href="#example-3">Example</a></h3>
<p>The following is an example using arithmetic literals and the <em>car</em> relation.</p>
<pre><code class="language-datalog">.pragma arithmetic_literals.
.assert car(make: string, model: string, age: integer).

antique(X, Y) :- car(X, Y, _) AND X *= &quot;[dD]uesenberg&quot;.
antique(X, Y) :- car(X, Y, _) AND Y = &quot;model t&quot;.
antique(X, Y) :- car(X, Y, Z) AND Z &gt; 50.
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="queries-1"><a class="header" href="#queries-1">Queries</a></h1>
<p>A query is simply a goal without sub-goals (or a rule without a body). It is assumed that all intensional relations have been inferred using the program’s rules and so the goal’s predicate may be extensional or intensional.</p>
<p><img src="vnd_datalog_text/images/query.png" alt="query" /></p>
<p>While a query is just a goal it is syntactically distinct <strong>either</strong> with the prefix <code>&quot;?-&quot;</code> <strong>or</strong> the suffix <code>&quot;?&quot;</code>.</p>
<pre><code class="language-ebnf">query   ::= ( &quot;?-&quot; atom &quot;.&quot; ) | ( atom &quot;?&quot; ) ;
</code></pre>
<p>The following are equivalent queries.</p>
<pre><code class="language-datalog">?- ancestor(xerces, X).
ancestor(xerces, X)?
</code></pre>
<h2 id="query-forms"><a class="header" href="#query-forms">Query Forms</a></h2>
<p>While a query is syntactically simple, an Atom with constant <em>and</em> variable
terms, it’s application falls into some distinct patterns or forms.</p>
<ul>
<li><em>Existential</em> – determines the existance of a fact by only providing
constant terms; this can be reduced to a boolean response value.</li>
<li><em>Selection</em> – one or more variables will result in all facts that match any
provided constants. </li>
<li><em>Projection</em> (narrower) – one or more anonymous variables will remove the
corresponding attribute from any results.</li>
</ul>
<h2 id="examples-4"><a class="header" href="#examples-4">Examples</a></h2>
<p>We refer to our common syllogism example.</p>
<pre><code class="language-datalog">human(&quot;Socrates&quot;).

mortal(X) &lt;- human(X).

?- mortal(&quot;Socrates&quot;).
</code></pre>
<p>The execution of this program will start with the goal query
<code>mortal(&quot;Socrates&quot;)</code> which can be read as “<em>is there an atom with the label
‘mortal’ with a single attribute value ‘Socrates’</em>?”. </p>
<pre><code class="language-text">+------------+
| _: string  |
+============+
| &quot;Socrates&quot; |
+------------+
</code></pre>
<p>As all terms are constant in this query, a processor  MAY return a boolean
value rather than the matching fact, in this case <code>true</code>.</p>
<pre><code class="language-text">+------------+
| _: boolean |
+============+
| true       |
+------------+
</code></pre>
<p>However, if we were to change the final query to replace the constant with a variable, as follows:</p>
<pre><code class="language-datalog">?- mortal(X).
</code></pre>
<p>The program will select all matching (in this case all) facts from the
<em>mortal</em> relation. In this case the column is named for the variable <code>X</code>, the
previous example used the anonymous identifier.</p>
<pre><code class="language-text">+------------+
| X: string  |
+============+
| &quot;Socrates&quot; |
+------------+
</code></pre>
<p>When the value <code>_</code> is used in a query it denotes an attribute of the relation that has no meaning
in either the query or the response. For example, in the following query we ask for all values of
the <em>model</em> attribute in the <em>car</em> relation where the <em>make</em> is “ford”, and ignore the age entirely.</p>
<pre><code class="language-datalog">.assert car(make: string, model: string, age: integer).

car(&quot;ford&quot;, X, _)?
</code></pre>
<p>The results of this query would not include the age column:</p>
<pre><code class="language-text">+------------+
| model      |
+============+
| edge       |
+------------+
| escort     |
+------------+
| fiesta     |
+------------+
| focus      |
+------------+
| fusion     |
+------------+
| mustang    |
+------------+
     ...
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="processing-instructions"><a class="header" href="#processing-instructions">Processing Instructions</a></h1>
<p>Processing Instructions are declarative statements that allow the parser and processor to enable and disable language features as well as load and save external relation data. </p>
<p>A conformant DATALOG-TEXT processor MUST signal the error <a href="vnd_datalog_text/errors.html#ERR_UNSUPPORTED_PROCESSING_INSTRUCTION"><code>ERR_UNSUPPORTED_PROCESSING_INSTRUCTION</code></a> when detecting a processing instruction identifier which they do not recognize or cannot support, even if it may be valid in some other version of this specification.</p>
<p><img src="vnd_datalog_text/images/processing-instruction.png" alt="processing-instruction" /></p>
<pre><code class="language-ebnf">processing-instruction  
      ::= &quot;.&quot; 
          ( pi-pragma 
          | pi-assert | pi-infer 
          | pi-input | pi-output ) 
          &quot;.&quot; ;
</code></pre>
<h2 id="strict-processing"><a class="header" href="#strict-processing">Strict Processing</a></h2>
<p>When strict processing is enabled (either by pragma or command-line) the following processing instructions MUST BE used:</p>
<ol>
<li>feature pragmas – all features required MUST BE declared before use.</li>
<li><code>assert</code> – all extensional relations MUST BE declared before use.</li>
<li><code>infer</code> – all intensional relations MUST BE declared before use.</li>
</ol>
<h2 id="processing-instruction-pragma"><a class="header" href="#processing-instruction-pragma">Processing Instruction <code>pragma</code></a></h2>
<p>A pragma is generally used to enable or disable some feature of either the parser or resolver. The first <code>predicate</code> in this production is termed the <em>pragma identifier</em>. The details of supported pragmas is in the separate section <a href="vnd_datalog_text/pragmas.html">§ Pragmas</a>.</p>
<p>A conformant DATALOG-TEXT processor MUST signal an error when detecting a pragma identifier which they do not recognize, even if it may be valid in some other version of this specification.</p>
<p><img src="vnd_datalog_text/images/pi-pragma.png" alt="pi-pragma" /></p>
<pre><code class="language-ebnf">pi-pragma
        ::= &quot;pragma&quot; predicate ( &quot;=&quot; constant )? ;
</code></pre>
<h3 id="errors-8"><a class="header" href="#errors-8">Errors</a></h3>
<ul>
<li><a href="vnd_datalog_text/errors.html#ERR_UNSUPPORTED_PRAGMA"><code>ERR_UNSUPPORTED_PRAGMA</code></a> – the initial predicate does not identify a supported pragma.</li>
</ul>
<h2 id="processing-instruction-assert"><a class="header" href="#processing-instruction-assert">Processing Instruction <code>assert</code></a></h2>
<p>The <code>assert</code> processing instruction declares a new relation in the extensional database. </p>
<p>The following constraints exist:</p>
<ol>
<li>the initial predicate MUST NOT be the label of an existing relation.</li>
<li>all attribute labels, if declared, MUST BE distinct.</li>
</ol>
<p>All extensional relations MUST be asserted before use in strict processing mode, an error MUST BE signaled otherwise. In non-strict mode a conforming DATALOG-TEXT processor MAY signal an error, or MAY continue processing as if the feature is enabled and infer the declaration and attribute types when the first fact is parsed. The use of this processing instruction is therefore optional, but recommended.</p>
<p><img src="vnd_datalog_text/images/pi-assert.png" alt="pi-assert" /></p>
<pre><code class="language-ebnf">pi-assert
        ::= &quot;assert&quot; relation-decl functional-dependency-list? ;
</code></pre>
<p>A relation declaration declares the types, and optionally the names, of the
attributes of a relation. The first predicate in <code>relation-decl</code> is the label
of the relation, the attributes themselves are defined within the following
parenthesis:</p>
<p><img src="vnd_datalog_text/images/relation-decl.png" alt="relation-decl" /></p>
<pre><code class="language-ebnf">relation-decl
        ::= predicate attribute-decl-list ;
</code></pre>
<p>Each attribute has a declared type, and may also be preceded by a predicate label.</p>
<p><img src="vnd_datalog_text/images/attribute-decl-list.png" alt="attribute-decl-list" /></p>
<pre><code class="language-ebnf">attribute-decl-list
        ::= &quot;(&quot; attribute-decl ( &quot;,&quot; attribute-decl )* &quot;)&quot; ;
</code></pre>
<p><img src="vnd_datalog_text/images/attribute-decl.png" alt="attribute-decl" /></p>
<pre><code class="language-ebnf">attribute-decl
        ::= ( predicate &quot;:&quot; )?
            ( &quot;boolean&quot; | &quot;float&quot; | &quot;decimal&quot; | &quot;integer&quot; | &quot;string&quot; ) ;
</code></pre>
<p>Note that the types <code>float</code> and <code>decimal</code> are only available if the feature <code>extended_numerics</code> is enabled.</p>
<h3 id="errors-9"><a class="header" href="#errors-9">Errors</a></h3>
<ul>
<li><a href="vnd_datalog_text/errors.html#ERR_INVALID_RELATION"><code>ERR_INVALID_RELATION</code></a> – the values for production <code>attribute-decl-list</code> where invalid, it was not possible to construct a compliant relation schema.</li>
<li><a href="vnd_datalog_text/errors.html#ERR_RELATION_ALREADY_EXISTS"><code>ERR_RELATION_ALREADY_EXISTS</code></a> – the predicate labeling the relation already exists (either as an extensional or intensional relation).</li>
</ul>
<h3 id="example-4"><a class="header" href="#example-4">Example</a></h3>
<p>The following declares a relation labeled <code>human</code> that has a single string attribute:</p>
<pre><code class="language-datalog">.assert human(string).
</code></pre>
<p>The following declares a relation labeled <code>human</code> that has a single string attribute, labeled as <code>name</code>:</p>
<pre><code class="language-datalog">.assert human(name: string).
</code></pre>
<p>The following is an error in that the <code>name</code> label is used for two separate attributes:</p>
<pre><code class="language-datalog">.assert human(name: string, name: string).
%% ==&gt; ERR_INVALID_RELATION
</code></pre>
<p>The following is an error, relations cannot be defined twice:</p>
<pre><code class="language-datalog">.assert human(name: string).
.assert human(first_name: string, last_name: string).
%% ==&gt; ERR_RELATION_ALREADY_EXISTS
</code></pre>
<h3 id="functional-dependencies-1"><a class="header" href="#functional-dependencies-1">Functional Dependencies</a></h3>
<p>The <code>functional-dependency-list</code> production introduces a relationship between one or more attributes on the left-hand side (determinant – a set denoted by $\small\alpha$) and one or more attributes on the right-hand side (dependent – a set denoted by $\small\beta$). This relationship denotes that for a relationship $\small R$, every valid combination of determinant values uniquely determines the value of the dependent values. The syntax for the dependency is intended to be as close to the mathematical form $\small R: \alpha \longrightarrow \beta$.</p>
<p>The following constraints exist:</p>
<ol start="2">
<li>the set of attribute identifiers comprising the set $\small\alpha$ MUST BE in $\small R$.</li>
<li>the set of attribute identifiers comprising the set $\small\beta$ MUST BE in $\small R$.</li>
<li>the same attribute identifier MUST NOT appear in both determinant and dependent.</li>
</ol>
<p>In strict processing mode this production is only valid if the corresponding language feature is enabled, an error MUST BE signaled otherwise. non-strict mode a conforming DATALOG-TEXT processor MAY signal an error, or MAY continue processing as if the feature is enabled.</p>
<p>Duplicate functional dependencies MUST NOT be treated as an error, they can be ignored; however, a DATALOG-TEXT processor MAY issue a warning on detection of duplicate values.</p>
<p><img src="vnd_datalog_text/images/functional-dependency-list.png" alt="functional-dependency-list" /></p>
<pre><code class="language-ebnf">functional-dependency-list
        ::= &quot;:&quot; functional-dependency ( &quot;;&quot; functional-dependency )* ;
</code></pre>
<p><img src="vnd_datalog_text/images/functional-dependency.png" alt="functional-dependency" /></p>
<pre><code class="language-ebnf">functional-dependency
        ::= attribute-index-list ( &quot;--&gt;&quot; | &quot;⟶&quot; ) attribute-index-list ;
</code></pre>
<p><img src="vnd_datalog_text/images/attribute-index-list.png" alt="attribute-index-list" /></p>
<pre><code class="language-ebnf">attribute-index-list
        ::= attribute-index ( &quot;,&quot; attribute-index )*
</code></pre>
<p>An attribute index is <em>either</em> an attribute label, if one has been declared for the relation, or an integer $\small i \in [1,|schema(R)|]$.</p>
<p><img src="vnd_datalog_text/images/attribute-index.png" alt="attribute-index" /></p>
<pre><code class="language-ebnf">attribute-index
        ::= integer | predicate
</code></pre>
<h4 id="errors-10"><a class="header" href="#errors-10">Errors</a></h4>
<ul>
<li><a href="vnd_datalog_text/errors.html#ERR_INVALID_ATTRIBUTE_INDEX"><code>ERR_INVALID_ATTRIBUTE_INDEX</code></a> –
the index (integer) is not valid within the relation’s schema. </li>
<li><a href="vnd_datalog_text/errors.html#ERR_INVALID_ATTRIBUTE_LABEL"><code>ERR_INVALID_ATTRIBUTE_LABEL</code></a> –
the label (predicate) is not valid within the relation’s schema. </li>
</ul>
<h4 id="examples-5"><a class="header" href="#examples-5">Examples</a></h4>
<p>Given the extensional relation <em>employee</em> the two functional dependencies in the
following are equivalent. Note that the implementation will ignore such duplicate declarations.</p>
<pre><code class="language-datalog">.feature(functional_dependencies).

.assert employee(id:integer, name:string) : id --&gt; name.
.assert employee(id:integer, name:string) : 1 ⟶ 2.
</code></pre>
<p>The following errors result from invalid attributes specified in the dependency.</p>
<pre><code class="language-datalog">.feature(functional_dependencies).

.assert employee(id:integer, name:string) : 1 ⟶ 42.
%% ==&gt; ERR_INVALID_ATTRIBUTE_INDEX
.assert employee(id:integer, name:string) : id --&gt; first_name.
%% ==&gt; ERR_INVALID_ATTRIBUTE_LABEL
</code></pre>
<h2 id="processing-instruction-infer"><a class="header" href="#processing-instruction-infer">Processing Instruction <code>infer</code></a></h2>
<p>In the same manner as <code>assert</code> above, the <code>infer</code> processing instruction declares a new relation in the intensional database. The alternate form is even more explicit in that it declares an intensional relation in terms of a previously declared extensional relation. </p>
<p>The following constraints exist:</p>
<ol>
<li>the initial predicate MUST NOT be the label of an existing extensional relation.</li>
<li>all attribute labels, if declared, MUST BE distinct.</li>
</ol>
<p>All intensional relations MUST be asserted before use in strict processing mode, an error MUST BE signaled otherwise. In non-strict mode a conforming DATALOG-TEXT processor MAY signal an error, or MAY continue processing as if the feature is enabled and infer the declaration and attribute types from rules as they are parsed. The use of this processing instruction is therefore optional, but recommended.</p>
<p><img src="vnd_datalog_text/images/pi-infer.png" alt="pi-infer" /></p>
<pre><code class="language-ebnf">pi-infer
        ::= &quot;infer&quot; ( relation-decl | &quot;from&quot; predicate ) ;
</code></pre>
<h3 id="errors-11"><a class="header" href="#errors-11">Errors</a></h3>
<ul>
<li><a href="vnd_datalog_text/errors.html#ERR_INVALID_RELATION"><code>ERR_INVALID_RELATION</code></a> – the values for
production <code>attribute-decl-list</code> where invalid, it was not possible to
construct a compliant relation schema. </li>
<li><a href="vnd_datalog_text/errors.html#ERR_RELATION_ALREADY_EXISTS"><code>ERR_RELATION_ALREADY_EXISTS</code></a> –
the predicate labeling the relation already exists (either as an extensional
or intensional relation). </li>
<li><a href="vnd_datalog_text/errors.html#ERR_PREDICATE_NOT_AN_EXTENSIONAL_RELATION"><code>ERR_PREDICATE_NOT_AN_EXTENSIONAL_RELATION</code></a>
– the predicate following the <code>from</code> keyword is not the label of an
extensional relation. </li>
</ul>
<h3 id="example-5"><a class="header" href="#example-5">Example</a></h3>
<p>The following declares a relation labeled <code>mortal</code> that has a single string attribute, labeled as <code>name</code>.</p>
<pre><code class="language-datalog">.infer mortal(name: string).
</code></pre>
<p>Alternatively the short-cut form is often more convenient but has the advantage that if the definition of <code>human</code> changes declaration changes accordingly.</p>
<pre><code class="language-datalog">.assert human(name: string).
.infer mortal from human.
</code></pre>
<p>The following error is raised as <code>humans</code> is incorrectly spelled.</p>
<pre><code class="language-datalog">.assert human(name: string).
.infer mortal from humans.
%% ==&gt; ERR_PREDICATE_NOT_AN_EXTENSIONAL_RELATION
</code></pre>
<h2 id="processing-instruction-input"><a class="header" href="#processing-instruction-input">Processing Instruction <code>input</code></a></h2>
<p>The <code>input</code> processing instruction instructs the parser to load facts for the named extensional relation from an external file. </p>
<blockquote>
<p>This specification does not determine whether loading external resources happens during parsing, at the completion of parsing, at evaluation time, or via a client initiated API call. However, as some errors (fact schema conformance for example) cannot happen until facts are loaded, this choice MAY defer the signaling of some critical errors.</p>
</blockquote>
<p><img src="vnd_datalog_text/images/pi-input.png" alt="pi-input" /></p>
<pre><code class="language-ebnf">pi-input
        ::= &quot;input&quot; io-details ;
</code></pre>
<p>The <code>io-details</code> production informs the parser of the expected media type for the external resource and any parameters for that media type.
The initial predicate in MUST BE the label of an extensional relation.</p>
<p>For a detailed discussion of media type handling, see <a href="vnd_datalog_text/resolvers.html#dataset-media-types">§ Dataset Media Types</a>.</p>
<p><img src="vnd_datalog_text/images/io-details.png" alt="io-details" /></p>
<pre><code class="language-ebnf">io-details
        ::= predicate parameter-list ;
</code></pre>
<p>The parameter list provides the values that are specified for a particular media type. For example, the media type <code>text/csv</code> supports two optional parameters, <code>charset</code> and <code>header</code>; the value of the header parameter MUST BE one of <code>present</code> or <code>absent</code> <span class="bibref inline"><a href="vnd_datalog_text/x_references.html#RFC4180">RFC4180</a></span>, section 3.</p>
<p><img src="vnd_datalog_text/images/parameter-list.png" alt="parameter-list" /></p>
<pre><code class="language-ebnf">parameter-list
        ::= parameter-assignment ( &quot;,&quot; parameter-assignment )* ;
</code></pre>
<p><img src="vnd_datalog_text/images/parameter-assignment.png" alt="parameter-assignment" /></p>
<pre><code class="language-ebnf">parameter-assignment
        ::= predicate &quot;=&quot; constant ;
</code></pre>
<h3 id="errors-12"><a class="header" href="#errors-12">Errors</a></h3>
<ul>
<li><a href="vnd_datalog_text/errors.html#ERR_PREDICATE_NOT_AN_EXTENSIONAL_RELATION"><code>ERR_PREDICATE_NOT_AN_EXTENSIONAL_RELATION</code></a>
– the predicate is not the label of an extensional relation, the <code>input</code>
processing instruction is only valid for extensional relations.</li>
<li><a href="vnd_datalog_text/errors.html#ERR_INVALID_URI"><code>ERR_INVALID_URI</code></a> – the <code>uri</code> parameter could
not be parsed, or has an unsupported scheme.</li>
<li><a href="vnd_datalog_text/errors.html#ERR_UNSUPPORTED_MEDIA_TYPE"><code>ERR_UNSUPPORTED_MEDIA_TYPE</code></a> – the
<code>type</code> parameter could not be parsed, or has an unsupported media type. </li>
<li><a href="vnd_datalog_text/errors.html#ERR_IO_INSTRUCTION_PARAMETER"><code>ERR_IO_INSTRUCTION_PARAMETER</code></a> –
another parameter provided for the type was either missing or has an
incorrect value. </li>
<li><a href="vnd_datalog_text/errors.html#ERR_INPUT_RESOURCE_DOES_NOT_EXIST"><code>ERR_INPUT_RESOURCE_DOES_NOT_EXIST</code></a>
– the URI could not be resolved to an accessible resource. </li>
<li><a href="vnd_datalog_text/errors.html#ERR_IO_SYSTEM_FAILURE"><code>ERR_IO_SYSTEM_FAILURE</code></a> – some other I/O
failure occurred. </li>
</ul>
<h3 id="examples-6"><a class="header" href="#examples-6">Examples</a></h3>
<p>In the following example the full media type is used and a parameter, allowing the resolver to pass the following request header to an HTTP request
<code>Accept: text/csv;header=absent</code></p>
<pre><code class="language-datalog">.assert human(name: string).
.input(human, uri=&quot;data/humans.csv&quot;, type=&quot;text/csv&quot;, header=absent).
</code></pre>
<p>In the following the short form of the media type is used, allowing the resolver to pass the following request header to an HTTP request
<code>Accept: text/csv</code></p>
<pre><code class="language-datalog">.assert human(name: string).
.input(human, uri=&quot;data/humans.csv&quot;, type=&quot;csv&quot;).
</code></pre>
<p>In the following no media type is present, in this case the resolver MUST follow the steps in <a href="vnd_datalog_text/resolvers.html">§ Resolvers</a>.</p>
<pre><code class="language-datalog">.assert human(name: string).
.input(human, uri=&quot;data/humans.csv&quot;).
</code></pre>
<p>The following error is signaled due to the media type <code>audio/mp4</code> which is not, and is unlikely to ever be, supported.</p>
<pre><code class="language-datalog">.assert human(name: string).
.input(human, uri=&quot;data/humans.csv&quot;, type=&quot;audio/mp4&quot;).
%% ==&gt; ERR_UNSUPPORTED_MEDIA_TYPE
</code></pre>
<p>The values for the <code>header</code> parameter are <code>absent</code> or <code>present</code>.</p>
<pre><code class="language-datalog">.assert human(name: string).
.input(human, uri=&quot;data/humans.csv&quot;, headers=yes_please).
%% ==&gt; ERR_IO_INSTRUCTION_PARAMETER
</code></pre>
<h2 id="processing-instruction-output"><a class="header" href="#processing-instruction-output">Processing Instruction <code>output</code></a></h2>
<p>The <code>output</code> processing instruction instructs the parser to write facts from the named intensional relation to an external file. </p>
<p>This specification does not determine whether writing to external resources happens during evaluation, at completion of evaluation, or via a client initiated API call. However, as some errors (un-writable output resource) cannot happen until intensional relations are stored, this choice MAY defer the signaling of some critical errors.</p>
<p><img src="vnd_datalog_text/images/pi-output.png" alt="pi-output" /></p>
<pre><code class="language-ebnf">pi-output  ::= &quot;output&quot; io-details &quot;.&quot; ;
</code></pre>
<h3 id="errors-13"><a class="header" href="#errors-13">Errors</a></h3>
<ul>
<li><a href="vnd_datalog_text/errors.html#ERR_PREDICATE_NOT_AN_INTENSIONAL_RELATION"><code>ERR_PREDICATE_NOT_AN_INTENSIONAL_RELATION</code></a>
– the predicate is not the label of an intensional relation, the <code>output</code>
processing instruction is only valid for intensional relations.</li>
<li><a href="vnd_datalog_text/errors.html#ERR_INVALID_URI"><code>ERR_INVALID_URI</code></a> – the <code>uri</code> parameter could
not be parsed, or has an unsupported scheme.</li>
<li><a href="vnd_datalog_text/errors.html#ERR_UNSUPPORTED_MEDIA_TYPE"><code>ERR_UNSUPPORTED_MEDIA_TYPE</code></a> – the
<code>type</code> parameter could not be parsed, or has an unsupported media type.</li>
<li><a href="vnd_datalog_text/errors.html#ERR_IO_INSTRUCTION_PARAMETER"><code>ERR_IO_INSTRUCTION_PARAMETER</code></a> –
another parameter provided for the type was either missing or has an
incorrect value.</li>
<li><a href="vnd_datalog_text/errors.html#ERR_OUTPUT_RESOURCE_NOT_WRITEABLE"><code>ERR_OUTPUT_RESOURCE_NOT_WRITEABLE</code></a>
– the URI identified a resource that could not be written to.</li>
<li><a href="vnd_datalog_text/errors.html#ERR_IO_SYSTEM_FAILURE"><code>ERR_IO_SYSTEM_FAILURE</code></a> – some other I/O
failure occurred.</li>
</ul>
<h3 id="examples-7"><a class="header" href="#examples-7">Examples</a></h3>
<pre><code class="language-datalog">.infer mortal(name: string).
.output(mortal, uri=&quot;data/mortals.txt&quot;).
</code></pre>
<pre><code class="language-datalog">.infer mortal(name: string).
.output(mortal, uri=&quot;data/mortals.txt&quot;, type=&quot;csv&quot;, separator=&quot;;&quot;, header=present).
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="comments"><a class="header" href="#comments">Comments</a></h1>
<p>Comments in Datalog are either 1) the <code>%</code> character and continue to the end of the line, or
2) C-style with <code>/*</code> to start and <code>*/</code> to end. These correspond to the same rules as Prolog.</p>
<p><img src="vnd_datalog_text/images/comment.png" alt="comment" /></p>
<pre><code class="language-ebnf">comment ::= line-comment | block-comment ;
</code></pre>
<p><img src="vnd_datalog_text/images/line-comment.png" alt="line-comment" /></p>
<pre><code class="language-ebnf">line-comment
        ::= &quot;%&quot; [^\r\n]* EOL ;
</code></pre>
<p><img src="vnd_datalog_text/images/block-comment.png" alt="block-comment" /></p>
<pre><code class="language-ebnf">block-comment
        ::= '/*' ( [^*] | '*'+ [^*/] )* '*'* '*/' ;
</code></pre>
<h2 id="example-6"><a class="header" href="#example-6">Example</a></h2>
<pre><code class="language-datalog">% Here's a comment
?- ancestor(xerces, X). % and another
?- ancestor(brooke /* and one inline */, X). % and another
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="terminallexical"><a class="header" href="#terminallexical">Terminal/Lexical</a></h1>
<p>The following are lexical rules that can be assumed by the non-terminal rules in previous sections.</p>
<pre><code class="language-ebnf">EOL     ::= &quot;\n&quot; | &quot;\r&quot; &quot;\n&quot;? ;

DQUOTE  ::= #x22 ;

UNDERSCORE
        ::= &quot;_&quot; ;

SPACE_SEP
        ::= ? corresponds to the Unicode category 'Zs' ? ;

WHITESPACE
        ::= SPACE_SEP | &quot;\t&quot; | EOL ;

LC_ALPHA
        ::= ? corresponds to the Unicode category 'Ll' ? ;

UC_ALPHA
        ::= ? corresponds to the Unicode category 'Lu' ? ;

TC_ALPHA
        ::= ? corresponds to the Unicode category 'Lt' ? ;

ALPHA   ::= LC_ALPHA | UC_ALPHA | TC_ALPHA ;

DIGIT   ::= ? corresponds to the Unicode category 'Nd' (decimal number) ? ;

HEXDIGIT
        ::= [0-9a-fA-F] ;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="resolvers"><a class="header" href="#resolvers">Resolvers</a></h1>
<p>Resolvers are used to download and parse content referenced from an initial
DATALOG-TEXT resource. In general these are datasets that are external to the
Datalog source and often in alternate representations. </p>
<h2 id="uri-references"><a class="header" href="#uri-references">URI References</a></h2>
<p>Relative URIs are resolved with base URIs as per <em>Uniform Resource Identifier
(URI): Generic Syntax</em> <span class="bibref
inline"><a href="vnd_datalog_text/x_references.html#RFC3986">RFC3986</a></span> using only the basic
algorithm in section 5.2. Neither Syntax-Based Normalization nor Scheme-Based
Normalization (described in sections 6.2.2 and 6.2.3 of RFC3986) are
performed.</p>
<p>The <a href="vnd_datalog_text/pragmas.html#pragma-base"><code>base</code> pragma</a> defines the Base URI used to
resolve relative URIs per RFC3986 § 5.1.1, “<em>Base URI Embedded in
Content</em>”. § 5.1.2, “<em>Base URI from the Encapsulating Entity</em>” defines
how the In-Scope Base URI may come from an encapsulating document, such as a
SOAP envelope with an <code>xml:base</code> directive or a mime multipart document with a
<code>Content-Location</code> header. The “<em>Retrieval URI</em>” identified in § 5.1.3, Base
“<em>URI from the Retrieval URI</em>”, is the URL from which a particular
DATALOG-TEXT resource was retrieved. If none of the above specifies the Base
URI, the default Base URI (§ 5.1.4, “<em>Default Base URI</em>”) is used.</p>
<p>In the case that multiple <code>base</code> pragmas exist, each replaces the previous value.</p>
<h3 id="content-negotiation"><a class="header" href="#content-negotiation">Content Negotiation</a></h3>
<p>This section applies to URI schemes, such as <code>http</code> and <code>https</code> that provide content negotiation.</p>
<p>The resolver MAY use a provided media type to construct an HTTP <code>Accept</code>
header (see <span class="bibref
inline"><a href="vnd_datalog_text/x_references.html#RFC7231">RFC7231</a></span> § 5.3.2) for URIs with <code>http</code> or <code>https</code> schemes, see <span class="bibref
inline"><a href="vnd_datalog_text/x_references.html#RFC2616">RFC2616</a>, § 14.1</span>.</p>
<p>In the following example no media type is provided.</p>
<pre><code class="language-datalog">.assert human(name: string).
.input human(uri=&quot;http://example.com/data/humans&quot;).
</code></pre>
<p>In this case the HTTP request contains a list of acceptable response types as
well as language and encoding preferences. In this case, not only does the
client accept CSV and TSV representations, it indicates its preference for CSV
over TSV.</p>
<pre><code class="language-http">GET /data/humans HTTP/1.1
Host: example.com
Accept: text/csv; q=0.8, text/tab-separated-values; q=0.4
Accept-Language: en-us
Accept-Encoding: gzip, deflate
</code></pre>
<p>While <code>Accept-Encoding</code> <span class="bibref
inline"><a href="vnd_datalog_text/x_references.html#RFC7231">RFC7231</a></span> § 5.3.4 and
<code>Accept-Language</code> <span class="bibref
inline"><a href="vnd_datalog_text/x_references.html#RFC7231">RFC7231</a></span> § 5.3.5 are RECOMMENDED, 
<code>Accept-Charset</code> <span class="bibref
inline"><a href="vnd_datalog_text/x_references.html#RFC7231">RFC7231</a></span> § 5.3.3 if present MAY only
take the value <code>UTF-8</code>. </p>
<h3 id="examples-8"><a class="header" href="#examples-8">Examples</a></h3>
<p>Given the following program, the input file is provided as an absolute URI and
can be fetched directly, the media type and parameters are also provided. </p>
<pre><code class="language-datalog">.assert human(name: string).
.input human(
    uri=&quot;http://example.com/data/humans.csv&quot;, 
    type=&quot;text/csv&quot;, 
    header=present).
</code></pre>
<p>The following is the resulting HTTP request.</p>
<pre><code class="language-http">GET /data/humans.csv HTTP/1.1
Host: example.com
Accept: text/csv;header=present
</code></pre>
<p>Given a relative URI, as shown below, the resolver requires a <em>base URI</em> to determine the absolute URI to fetch. An explicit base URI may be provided using the <code>base</code> pragma, or some other means such as processor command-line parameters, environment variables, or the current working directory of the host process<sup class="footnote-reference"><a href="#1">1</a></sup>.</p>
<pre><code class="language-datalog">.pragma base=&quot;https://example.com/datalog/&quot;.
.assert human(name: string).
.input human(uri=&quot;data/humans.csv&quot;, type=&quot;text/csv&quot;, header=present).
</code></pre>
<pre><code class="language-datalog">.assert human(name: string).
.input human(uri=&quot;data/humans.csv&quot;, type=&quot;text/csv&quot;, header=present).
</code></pre>
<h2 id="dataset-media-types"><a class="header" href="#dataset-media-types">Dataset Media Types</a></h2>
<p>The following media types are documented here, however only <code>text/csv</code> and <code>text/tab-separated-values</code> MUST be supported by a conforming DATALOG-TEXT processor.</p>
<table><thead><tr><th>Media Type</th><th>Short</th><th>Parameters</th><th>Conform</th><th>Expectations</th></tr></thead><tbody>
<tr><td>text/csv</td><td>csv</td><td>header</td><td>MUST</td><td>See <span class="bibref inline"><a href="vnd_datalog_text/x_references.html#RFC4180">RFC4180</a></span></td></tr>
<tr><td>text/tab-separated-values</td><td>tsv</td><td>N/A</td><td>MUST</td><td>See <span class="bibref inline"><a href="vnd_datalog_text/x_references.html#IANA-TSV">IANA-TSV</a></span></td></tr>
<tr><td>application/json</td><td>json</td><td>N/A</td><td>N/A</td><td>See <span class="bibref inline"><a href="vnd_datalog_text/x_references.html#RFC4627">RFC4627</a></span></td></tr>
<tr><td>application/vnd.sqlite3</td><td>sqlite3</td><td>N/A</td><td>N/A</td><td>See <span class="bibref inline"><a href="vnd_datalog_text/x_references.html#IANA-SQLITE3">IANA-SQLITE3</a></span></td></tr>
<tr><td>application/vnd.datalog</td><td>datalog</td><td>N/A</td><td>N/A</td><td>Used on output only to write DATALOG-TEXT from an in-memory representation</td></tr>
</tbody></table>
<h3 id="common-parameters"><a class="header" href="#common-parameters">Common Parameters</a></h3>
<ul>
<li><code>uri</code> – this MUST BE interpreted as a URI <span class="bibref inline"><a href="vnd_datalog_text/x_references.html#RFC3986">RFC3986</a></span> and handled as per <a href="vnd_datalog_text/resolvers.html#uri-references">§ URI References</a> above.</li>
<li><code>type</code> – this string value MUST BE either the type name and subtype name of a supported media type (i.e. <code>text/csv</code>) or one of the supported media type short form identifiers described in the <a href="vnd_datalog_text/resolvers.html#dataset-media-types">§ Dataset Media Types</a> table.</li>
</ul>
<h3 id="common-errors"><a class="header" href="#common-errors">Common Errors</a></h3>
<ul>
<li><a href="vnd_datalog_text/errors.html#ERR_IO_INSTRUCTION_PARAMETER"><code>ERR_IO_INSTRUCTION_PARAMETER</code></a> –
one of the specified parameters was incorrectly specified.</li>
</ul>
<h3 id="textcsv-parameters"><a class="header" href="#textcsv-parameters">text/csv Parameters</a></h3>
<ul>
<li><code>header</code> – one of the following values <code>{present, absent}</code> from <span class="bibref inline"><a href="vnd_datalog_text/x_references.html#RFC4180">RFC4180</a></span>.</li>
<li><code>columns</code> – a comma-separated list of either positive integers (the first
column is column <code>1</code>)) or inclusive range specifiers of the form <code>[min:max]</code>
where min and max are optional positive integers. If min is not present it
is assumed to be the initial attribute index of <code>1</code>, if max is not present
it is assumed to the last attribute index $\small j$ in
$\small(\alpha_1,\ldots,\alpha_j)$.</li>
</ul>
<h4 id="errors-14"><a class="header" href="#errors-14">Errors</a></h4>
<ul>
<li><a href="vnd_datalog_text/errors.html#ERR_INVALID_ATTRIBUTE_INDEX"><code>ERR_INVALID_ATTRIBUTE_INDEX</code></a> – a
value in the <code>columns</code> parameter is not a valid attribute index in this relation.</li>
</ul>
<h4 id="example-7"><a class="header" href="#example-7">Example</a></h4>
<pre><code class="language-datalog">.assert human(name: string).
.input human( 
    uri=&quot;http://example.com/data/humans.csv&quot;, 
    type=&quot;text/csv&quot;, 
    columns=&quot;2&quot;,
    header=present).
</code></pre>
<h3 id="texttsv-parameters"><a class="header" href="#texttsv-parameters">text/tsv Parameters</a></h3>
<ul>
<li><code>columns</code> – see <a href="vnd_datalog_text/resolvers.html#textcsv-parameters">§ Text/CSV Parameters</a>.</li>
</ul>
<p>According to <span class="bibref
inline"><a href="vnd_datalog_text/x_references.html#IANA-TSV">IANA-TSV</a></span> in the <code>tsv</code> production
(copied below) the name line MUST BE present and so no <code>header</code> parameter is
exposed for this type. </p>
<pre><code class="language-ebnf">tsv      ::= nameline record+ ;
</code></pre>
<h4 id="example-8"><a class="header" href="#example-8">Example</a></h4>
<pre><code class="language-datalog">.assert car(make: string, model: string, year: integer).
.input car( 
    uri=&quot;http://example.com/data/cars.tsv&quot;, 
    type=&quot;text/tab-separated-values&quot;, 
    columns=&quot;[1:2],4&quot;).
</code></pre>
<h3 id="applicationjson-parameters"><a class="header" href="#applicationjson-parameters">application/json Parameters</a></h3>
<p><em>This section is non-normative.</em></p>
<p>The JSON data interchange syntax <span class="bibref
inline"><a href="vnd_datalog_text/x_references.html#ECMA-JSON">ECMA-JSON</a></span> is a well-defined and
simple interchange format and can be used to represent datasets, given the
following structural restrictions.</p>
<ol>
<li>The JSON root value MUST be an array.</li>
<li>Each member of this array MUST be <em>either</em>:
<ol>
<li>An array where each value being MUST be an atomic value (string, number,
boolean).</li>
<li>An object where each member value MUST be an atomic value (string, number,
boolean).</li>
</ol>
</li>
<li>All members of this array MUST be homogenous.</li>
</ol>
<p>Additional, more complex structures MAY be supported by a DATALOG-TEXT
processor.</p>
<ul>
<li><code>columns</code> – this MUST only be used when each member of the JSON array is
also an array. See <a href="vnd_datalog_text/resolvers.html#textcsv-parameters">§ Text/CSV Parameters</a>.</li>
<li><code>members</code> – this MUST only be used when each member of the JSON array is
an object and is a comma-separated list of member names.</li>
</ul>
<h4 id="errors-15"><a class="header" href="#errors-15">Errors</a></h4>
<ul>
<li><a href="vnd_datalog_text/errors.html#ERR_INVALID_ATTRIBUTE_LABEL"><code>ERR_INVALID_ATTRIBUTE_LABEL</code></a> – a
value in the <code>members</code> parameter is not a valid attribute label in this relation.</li>
</ul>
<h4 id="examples-9"><a class="header" href="#examples-9">Examples</a></h4>
<p>Given the following, array-shaped, JSON value.</p>
<pre><code class="language-json">[
  [&quot;ford&quot;, &quot;fiesta&quot;, &quot;uk&quot;, 2010],
  [&quot;ford&quot;, &quot;escort&quot;, &quot;uk&quot;, 2008]
]
</code></pre>
<p>The input processing instruction for the relation <code>car</code> specifies columns 1, 2, and
4 to skip the unused third column. By default an array-shaped input will match
by position and there MUST be the same number of values in each array as there are
attributes in the relation.</p>
<pre><code class="language-datalog">.assert car(make: string, model: string, year: integer).
.input car( 
    uri=&quot;http://example.com/data/cars.json&quot;,
    type=&quot;application/vnd.sqlite3&quot;,
    columns=&quot;1,2,4&quot;).
</code></pre>
<p>Given the following, object-shaped, JSON value.</p>
<pre><code class="language-json">[
  {&quot;make&quot;: &quot;ford&quot;, &quot;model&quot;: &quot;fiesta&quot;, &quot;geo&quot;: &quot;uk&quot;, &quot;year&quot;: 2010},
  {&quot;make&quot;: &quot;ford&quot;, &quot;model&quot;: &quot;escort&quot;, &quot;geo&quot;: &quot;uk&quot;, &quot;year&quot;: 2008}
]
</code></pre>
<p>The input processing instruction for the relation <code>car</code> specifies the members
make, model, and year but not the geo value. By default an object-shaped input
is matched by label <strong>IFF</strong> all attributes in the relation are named, or else by
position. If matched by label the object may have more members than the
relation has attributes; if matched by position the length of object and
relation MUST be equal.</p>
<pre><code class="language-datalog">.assert car(make: string, model: string, year: integer).
.input car( 
    uri=&quot;http://example.com/data/cars.json&quot;,
    type=&quot;application/vnd.sqlite3&quot;,
    members=&quot;make,model,year&quot;).
</code></pre>
<h3 id="applicationvndsqlite3-parameters"><a class="header" href="#applicationvndsqlite3-parameters">application/vnd.sqlite3 Parameters</a></h3>
<p><em>This section is non-normative.</em></p>
<ul>
<li><code>table</code> – the name of the table in the database to read from, or write to. If missing the processor MAY use the relation name as the table name, or MAY signal the error <a href="vnd_datalog_text/errors.html#ERR_IO_INSTRUCTION_PARAMETER"><code>ERR_IO_INSTRUCTION_PARAMETER</code></a>.</li>
<li><code>columns</code> – a comma-separated list of column names in the table, these are matched positionally with relation attributes. If missing the processor MAY use the attribute names as column names, or MAY signal the error <a href="vnd_datalog_text/errors.html#ERR_IO_INSTRUCTION_PARAMETER"><code>ERR_IO_INSTRUCTION_PARAMETER</code></a>.</li>
</ul>
<p>According to <span class="bibref inline"><a href="vnd_datalog_text/x_references.html#SQLITE3-URI">SQLITE3-URI</a></span> the URI specified for the database location MUST have the scheme <code>file</code> <span class="bibref inline"><a href="vnd_datalog_text/x_references.html#RFC8089">RFC8089</a></span>.</p>
<p>A conforming DATALOG-TEXT processor MAY choose to validate these parameters at parse time or MAY wait until the actual input/output operation is required. In either case if the processor determines that the table or columns specified in these parameters does not match the schema of the relation the processor MUST signal the error <a href="vnd_datalog_text/errors.html#ERR_IO_INSTRUCTION_PARAMETER"><code>ERR_IO_INSTRUCTION_PARAMETER</code></a>.</p>
<h4 id="example-9"><a class="header" href="#example-9">Example</a></h4>
<p>In the following the intensional relation <code>mortal</code> is output to a SQLite database.</p>
<pre><code class="language-datalog">.infer mortal(name: string).
.output mortal( 
    uri=&quot;file:///var/db/results.sql?cache=private&amp;mode=rwc&quot;, 
    type=&quot;application/vnd.sqlite3&quot;,
    table=&quot;mortals&quot;,
    columns=&quot;short_name&quot;).
</code></pre>
<h3 id="textdatalog"><a class="header" href="#textdatalog">Text/Datalog</a></h3>
<p><em>This section is non-normative.</em></p>
<p>In either the input or output cases the representation is a list of facts that
corresponds to the grammar production <code>assertion</code>, see <a href="vnd_datalog_text/grammar_facts.html">§ Relations &amp; Facts</a>.</p>
<p>&nbsp;</p>
<hr />
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>See The Open Group <a href="https://pubs.opengroup.org/onlinepubs/007904975/functions/getcwd.html">man page</a> for the <code>getcwd()</code> function.</p>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pragmas"><a class="header" href="#pragmas">Pragmas</a></h1>
<p><strong>REREAD THIS SECTION</strong></p>
<p>A number of pragmas below are termed <em>feature pragmas</em> as they are boolean
gates that enable or disable specific language featues. Use of syntax
associated with a disabled language feature MAY result in errors. </p>
<p>A conformant DATALOG-TEXT processor in strict mode MUST signal an error,
otherwise the processor MAY assume the feature is enabled due to its usage. A
conformant DATALOG-TEXT processor MUST signal an error when detecting a
feature identifier which they do not recognize, even if it may be valid in
some other version of this specification.</p>
<p>As feature pragmas are boolean parameters, the following two pragmas are equivalent</p>
<pre><code class="language-datalog">.pragma negation.
.pragma negation=true.
</code></pre>
<p>This also implies you can force a feature to be disabled in the following manner.</p>
<pre><code class="language-datalog">.pragma negation=false.
</code></pre>
<p>Duplicate features listed in the same processing instruction, or multiple processing instructions MUST NOT be treated as an error, they are simply combined and de-duplicated as a set. A DATALOG-TEXT processor MAY signal a <a href="vnd_datalog_text/errors.html#WARN_DUPLICATE"><code>WARN_DUPLICATE</code></a> warning on detection of duplicate values.</p>
<h2 id="pragma-base"><a class="header" href="#pragma-base">Pragma <code>base</code></a></h2>
<p>If the <code>base</code> pragma is not specified then any references in the subject resource are relative to the resource location if known by the parser, or relative to the process performing the parsing. </p>
<p>Any use of the <code>base</code> pragma MUST include a constant string value that can be interpreted as a valid absolute URI (section 4.3 “<em>Absolute URI</em>” in <span class="bibref inline"><a href="vnd_datalog_text/x_references.html#RFC3986">RFC3986</a></span>).</p>
<p><strong>Default Value</strong>: <code>&quot;&quot;</code>, see <a href="vnd_datalog_text/resolvers.html#uri-references">§ URI References</a>.</p>
<h3 id="errors-16"><a class="header" href="#errors-16">Errors</a></h3>
<ul>
<li><a href="vnd_datalog_text/errors.html#ERR_MISSING_VALUE"><code>ERR_MISSING_VALUE</code></a> – The URI was not present.</li>
<li><a href="vnd_datalog_text/errors.html#ERR_INVALID_TYPE"><code>ERR_INVALID_TYPE</code></a> – The value provided was not a string.</li>
<li><a href="vnd_datalog_text/errors.html#ERR_INVALID_URI"><code>ERR_INVALID_URI</code></a> – Could not parse the URI, or it was not absolute.</li>
</ul>
<h3 id="examples-10"><a class="header" href="#examples-10">Examples</a></h3>
<p>In the following example the base IRI is <em>implicit</em> and is determined by the resolver to dereference the relative value “data/humans.csv”.</p>
<pre><code class="language-datalog">.assert human(string).
.input(human, &quot;data/humans.csv&quot;, &quot;csv&quot;).
</code></pre>
<p>In the following example the base IRI is <em>explicitly</em> declared and so the input for <code>human</code> is clearly “https://example.com/datalog/data/humans.csv”.</p>
<pre><code class="language-datalog">.pragma base=&quot;https://example.com/datalog/&quot;.
.assert human(string).
.input(human, &quot;data/humans.csv&quot;, &quot;csv&quot;).
</code></pre>
<p>The following are invalid.</p>
<pre><code class="language-datalog">.pragma base.
%% ==&gt; ERR_MISSING_VALUE
</code></pre>
<pre><code class="language-datalog">.pragma base=&quot;/resources&quot;.
%% ==&gt; ERR_INVALID_URI
</code></pre>
<pre><code class="language-datalog">3M.pragma base=true.
%% ==&gt; ERR_INVALID_TYPE
</code></pre>
<h2 id="pragma-constraints-feature"><a class="header" href="#pragma-constraints-feature">Pragma <code>constraints</code> (feature)</a></h2>
<p>Enable rules to omit the head and become a constraint, as describe in <a href="vnd_datalog_text/grammar_rules.html#rule-body--constraints">§ Rule Body &amp; Constraints</a>.</p>
<p><strong>Default Value</strong>: <code>false</code></p>
<h3 id="errors-17"><a class="header" href="#errors-17">Errors</a></h3>
<ul>
<li><a href="vnd_datalog_text/errors.html#ERR_UNSUPPORTED_FEATURE"><code>ERR_UNSUPPORTED_FEATURE</code></a> – This feature is not supported by this parser.</li>
<li><a href="vnd_datalog_text/errors.html#ERR_INVALID_TYPE"><code>ERR_INVALID_TYPE</code></a> – the value provided was not of type boolean.</li>
</ul>
<h2 id="pragma-disjunction-feature"><a class="header" href="#pragma-disjunction-feature">Pragma <code>disjunction</code> (feature)</a></h2>
<p>Enable multiple atoms in a rule head, as describe in <a href="vnd_datalog_text/grammar_rules.html#rule-head--disjunction">§ Rule Head &amp; Disjunction</a>.</p>
<p><strong>Default Value</strong>: <code>false</code></p>
<h3 id="errors-18"><a class="header" href="#errors-18">Errors</a></h3>
<ul>
<li><a href="vnd_datalog_text/errors.html#ERR_UNSUPPORTED_FEATURE"><code>ERR_UNSUPPORTED_FEATURE</code></a> – This feature is not supported by this parser.</li>
<li><a href="vnd_datalog_text/errors.html#ERR_INVALID_TYPE"><code>ERR_INVALID_TYPE</code></a> – the value provided was not of type boolean.</li>
</ul>
<h2 id="pragma-extended_numerics-feature"><a class="header" href="#pragma-extended_numerics-feature">Pragma <code>extended_numerics</code> (feature)</a></h2>
<p>Enable the types <code>float</code> and <code>decimal</code>, as describe in <a href="vnd_datalog_text/grammar_constants.html#numbers">§ Numbers</a>.</p>
<p><strong>Default Value</strong>: <code>false</code></p>
<h3 id="errors-19"><a class="header" href="#errors-19">Errors</a></h3>
<ul>
<li><a href="vnd_datalog_text/errors.html#ERR_UNSUPPORTED_FEATURE"><code>ERR_UNSUPPORTED_FEATURE</code></a> – This feature is not supported by this parser.</li>
<li><a href="vnd_datalog_text/errors.html#ERR_INVALID_TYPE"><code>ERR_INVALID_TYPE</code></a> – the value provided was not of type boolean.</li>
</ul>
<h2 id="pragma-functional_dependencies-feature"><a class="header" href="#pragma-functional_dependencies-feature">Pragma <code>functional_dependencies</code> (feature)</a></h2>
<p>Enable the <code>fd</code> processing instruction, as describe in <a href="vnd_datalog_text/grammar_pi.html#processing-instruction-fd">§ Processing Instruction <code>fd</code></a></p>
<p><strong>Default Value</strong>: <code>false</code></p>
<h3 id="errors-20"><a class="header" href="#errors-20">Errors</a></h3>
<ul>
<li><a href="vnd_datalog_text/errors.html#ERR_UNSUPPORTED_FEATURE"><code>ERR_UNSUPPORTED_FEATURE</code></a> – This feature is not supported by this parser.</li>
<li><a href="vnd_datalog_text/errors.html#ERR_INVALID_TYPE"><code>ERR_INVALID_TYPE</code></a> – the value provided was not of type boolean.</li>
</ul>
<h2 id="pragma-negation-feature"><a class="header" href="#pragma-negation-feature">Pragma <code>negation</code> (feature)</a></h2>
<p>Enable negated literals within a rule, as describe in <a href="vnd_datalog_text/grammar_literals.html#negation">§ Negation</a>.</p>
<p><strong>Default Value</strong>: <code>false</code></p>
<h3 id="errors-21"><a class="header" href="#errors-21">Errors</a></h3>
<ul>
<li><a href="vnd_datalog_text/errors.html#ERR_UNSUPPORTED_FEATURE"><code>ERR_UNSUPPORTED_FEATURE</code></a> – This feature is not supported by this parser.</li>
<li><a href="vnd_datalog_text/errors.html#ERR_INVALID_TYPE"><code>ERR_INVALID_TYPE</code></a> – the value provided was not of type boolean.</li>
</ul>
<h2 id="pragma-results"><a class="header" href="#pragma-results">Pragma <code>results</code></a></h2>
<p>Determines whether query results are displayed in DATALOG-TEXT or tabular form. The following are valid values for the <code>results</code> pragma. This specification does not define the default form; however, it is RECOMMENDED to use tabular form in interactive tools.</p>
<p>The following are valid values for the result pragma. The details of each supported results form is described in the appendix <a href="vnd_datalog_text/x_result_forms.html">§ Result Formats</a>.</p>
<ul>
<li><code>native</code> – results are returned as constant values or facts; this format MUST be supported by a conforming DATALOG-TEXT processor that displays results in human-readable form.</li>
<li><code>tabular</code> – results are returned in a tabular form; this format is optional but RECOMMENDED.</li>
</ul>
<p><strong>Default Value</strong>: undefined.</p>
<h3 id="errors-22"><a class="header" href="#errors-22">Errors</a></h3>
<ul>
<li><a href="vnd_datalog_text/errors.html#ERR_UNSUPPORTED_FEATURE"><code>ERR_UNSUPPORTED_FEATURE</code></a> – This feature is not supported by this parser.</li>
<li><a href="vnd_datalog_text/errors.html#ERR_INVALID_TYPE"><code>ERR_INVALID_TYPE</code></a> – the value provided was not a string.</li>
<li><a href="vnd_datalog_text/errors.html#ERR_INVALID_VALUE_FOR_TYPE"><code>ERR_INVALID_VALUE_FOR_TYPE</code></a> – Invalid value for the results form, see <a href="vnd_datalog_text/x_result_forms.html">§ Result Formats</a>.</li>
</ul>
<h2 id="pragma-strict"><a class="header" href="#pragma-strict">Pragma <code>strict</code></a></h2>
<p>This enables the strict processing mode as described in <a href="vnd_datalog_text/conformance.html#strict-vs-lax-processing">§ Strict vs Lax Processing</a> in Conformance and <a href="vnd_datalog_text/grammar_pi.html#strict-processing">§ Strict Processing</a> in Processing Instructions.
This pragma MUST BE supported by a conforming DATALOG-TEXT processor.</p>
<p><strong>Default Value</strong>: undefined.</p>
<h3 id="errors-23"><a class="header" href="#errors-23">Errors</a></h3>
<ul>
<li><a href="vnd_datalog_text/errors.html#ERR_INVALID_TYPE"><code>ERR_INVALID_TYPE</code></a> – the value provided was not of type boolean.</li>
</ul>
<h3 id="examples-11"><a class="header" href="#examples-11">Examples</a></h3>
<p>The following program will signal an error as it is required that all relations be explicitly declared before use when in strict processing mode.</p>
<pre><code class="language-datalog">.pragma strict.

human(socrates).
%% ==&gt; ERR_PREDICATE_NOT_AN_EXTENSIONAL_RELATION
</code></pre>
<p>A similar error is signaled for intensional relations.</p>
<pre><code class="language-datalog">.pragma strict.
.assert human(string).

human(socrates).
mortal(X) :- human(X) AND NOT home(olympus).
%% ==&gt; ERR_PREDICATE_NOT_AN_INTENSIONAL_RELATION
</code></pre>
<p>Finally, errors are signaled for undeclared use of features.</p>
<pre><code class="language-datalog">.pragma strict.
.assert human(string).
.assert home(string).
.infer mortal from human.

mortal(X) :- human(X) AND NOT home(olympus).
%% ==&gt; ERR_FEATURE_NOT_ENABLED
</code></pre>
<p>The following is invalid.</p>
<pre><code class="language-datalog">.pragma strict=&quot;yes&quot;.
%% ==&gt; ERR_INVALID_TYPE
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="errors-24"><a class="header" href="#errors-24">Errors</a></h1>
<p>This specification expects parsers of to emit certain errors when dealing with the semantics of the resource content (we do not address low-leve lexing/parsing errors). Each instance of an error reported to the client of the parser SHOULD include a message that denotes the details of the elements involved and SHOULD, if possible, the source location.</p>
<p>The following errors MUST be supported in a conforming DATALOG-TEXT processor. The naming convention used here for errors is commonly referred to as <em><a href="https://en.wikipedia.org/?title=SCREAMING_SNAKE_CASE&amp;redirect=no">Screaming Snake Case</a></em> where all characters are in upper case and all words are separated by underscores. A conforming DATALOG-TEXT processor SHOULD adapt this naming convention to the idiomatic form expected by a programmer in the implementation language.</p>
<p>Additional errors MAY be added, but where possible existing errors SHOULD BE used, distinguished by the <code>message</code> (See the non-normative <a href="vnd_datalog_text/errors.html#error_type">§ Error Type</a> below) field on the error instance. Alternatively more detailed errors may be wrapped within one of the errors below using the <code>caused_by</code> field on the error instance.</p>
<h2 id="core-errors"><a class="header" href="#core-errors">Core Errors</a></h2>
<dl class="enum">
    <dt id="ERR_UNSUPPORTED_DIALECT">ERR_UNSUPPORTED_DIALECT</dt>
    <dd>
<p>The dialect specified in the <code>vnd.datalog</code> media type was not identified, or otherwise not supported by this parser.
</dd>
<dt id="ERR_UNSUPPORTED_SYNTAX">ERR_UNSUPPORTED_SYNTAX</dt>
<dd></p>
<p>The parser found syntax that is not supported by the dialect specified in the <code>vnd.datalog</code> media type.
</dd>
<dt id="ERR_UNSUPPORTED_FEATURE">ERR_UNSUPPORTED_FEATURE</dt>
<dd></p>
<p>A feature identified by a feature pragma is not supported by this parser.
</dd>
<dt id="ERR_FEATURE_NOT_ENABLED">ERR_FEATURE_NOT_ENABLED</dt>
<dd></p>
<p>A required language feature during parsing was not enabled in the <code>features</code> pragma. The error <code>ERR_FEATURE_NOT_ENABLED</code> should be signaled instead if enabling the feature would result in such an error.
</dd>
<dt id="ERR_UNSUPPORTED_PROCESSING_INSTRUCTION">ERR_UNSUPPORTED_PROCESSING_INSTRUCTION</dt>
<dd></p>
<p>The processing instruction was not identified, or otherwise not supported by this parser.
</dd>
<dt id="ERR_UNSUPPORTED_PRAGMA">ERR_UNSUPPORTED_PRAGMA</dt>
<dd></p>
<p>The pragma was not identified, or otherwise not supported by this parser.
</dd>
<dt id="ERR_INCONSISTENT_FACT_SCHEMA">ERR_INCONSISTENT_FACT_SCHEMA</dt>
<dd></p>
<p>Two facts are asserted but with different schema, or a fact is asserted with a different schema than it’s declared relation.</p>
<p>Given the following processing instruction <code>.assert human(string).</code>, the following fact is inconsistent<code> human(24).</code></p>
<p>Or, if no relation declaration exists the first instance of a fact, say <code>human(&quot;Alice&quot;).</code>, is used to infer the relation schema and thus the following fact is inconsistent <code>human(24).</code>
</dd>
<dt id="ERR_PREDICATE_NOT_AN_EXTENSIONAL_RELATION">ERR_PREDICATE_NOT_AN_EXTENSIONAL_RELATION</dt>
<dd></p>
<p>A predicate is used in a context that identifies an extensional relation, however the label was not in the extensional database. 
</dd>
<dt id="ERR_PREDICATE_NOT_AN_INTENSIONAL_RELATION">ERR_PREDICATE_NOT_AN_INTENSIONAL_RELATION</dt>
<dd></p>
<p>A predicate is used in a context that identifies an intensional relation, however the label was not in the intensional database.
</dd>
<dt id="ERR_RELATION_ALREADY_EXISTS">ERR_RELATION_ALREADY_EXISTS</dt>
<dd></p>
<p>An attempt was made to declare a relation where one already exists.
</dd>
<dt id="ERR_EXTENSIONAL_RELATION_IN_RULE_HEAD">ERR_EXTENSIONAL_RELATION_IN_RULE_HEAD</dt>
<dd></p>
<p>A previously identified extensional relation, either with the <code>assert</code> processing instruction or inferred from a fact, appears in the head of a rule.
</dd>
<dt id="ERR_HEAD_VARIABLE_NOT_IN_POSITIVE_RELATIONAL_LITERAL">ERR_HEAD_VARIABLE_NOT_IN_POSITIVE_RELATIONAL_LITERAL</dt>
<dd></p>
<p>A variable that is used within the head of a rule does not also appear in a positive <em>relational</em> literal. For example, the following is invalid: <code>a(X) :- b(Y)</code>.
</dd>
<dt id="ERR_INVALID_NUMBER_OF_ATOMS_IN_HEAD">ERR_INVALID_NUMBER_OF_ATOMS_IN_HEAD</dt>
<dd></p>
<p>A $\small\text{Datalog}$ program requires one, and only one, atom in a rule’s head. Also see <a href="vnd_datalog_text/errors.html#with-constraints">§ With Constraints</a> and <a href="vnd_datalog_text/errors.html#with-disjunction">§ With Disjunction</a> for modifications to this error condition.
</dd>
<dt id="ERR_INVALID_TYPE">ERR_INVALID_TYPE</dt>
<dd></p>
<p>A value was provided which did not match the expected type.
</dd>
<dt id="ERR_MISSING_VALUE">ERR_MISSING_VALUE</dt>
<dd></p>
<p>An expected value was not found.
</dd>
<dt id="ERR_INVALID_VALUE_FOR_TYPE">ERR_INVALID_VALUE_FOR_TYPE</dt>
<dd></p>
<p>A value was provided that is an invalid representation of the expected type.
</dd>
<dt id="ERR_INVALID_RELATION">ERR_INVALID_RELATION</dt>
<dd></p>
<p>A relation cannot be constructed, either from the values provided to an <code>assert</code> or <code>infer</code> processing instruction or during rule evaluation.
</dd>
<dt id="WARN_DUPLICATE">WARN_DUPLICATE</dt>
<dd></p>
<p>Signaled on any duplicate declaration, processing instruction, fact, rule, or query.
</dd>
<dt id="WARN_RULE_IS_ALWAYS_TRUE">WARN_RULE_IS_ALWAYS_TRUE</dt>
<dd></p>
<p>This rule will always evaluate to true. See also <code>WARN_ARITHMETIC_LITERAL_IS_ALWAYS_TRUE</code>.
</dd>
<dt id="WARN_RULE_IS_ALWAYS_FALSE">WARN_RULE_IS_ALWAYS_FALSE</dt>
<dd></p>
<p>This rule will always evaluate to false. See also <code>WARN_ARITHMETIC_LITERAL_IS_ALWAYS_FALSE</code>.
</dd></p>
</dl>
<h2 id="resolver-errors"><a class="header" href="#resolver-errors">Resolver Errors</a></h2>
<p>The following errors are introduced for use by the <em>resolver</em> subcomponent of the DATALOG-TEXT processor.</p>
<dl class="enum">
    <dt id="ERR_UNSUPPORTED_MEDIA_TYPE">ERR_UNSUPPORTED_MEDIA_TYPE</dt>
    <dd>
<p>A media type present in an <code>input</code> or <code>output``input</code> or <code>output</code> processing instruction is not supported by this processor.
</dd>
<dt id="ERR_INVALID_URI">ERR_INVALID_URI</dt>
<dd></p>
<p>The URI present in an <code>input</code> or <code>output</code> processing instruction could not be parsed, and constructed as a valid absolute URI.
</dd>
<dt id="ERR_INPUT_RESOURCE_DOES_NOT_EXIST">ERR_INPUT_RESOURCE_DOES_NOT_EXIST</dt>
<dd></p>
<p>Having constructed a valid absolute URI no resource was found. For example in an HTTP response this would be the error 404 <code>NOT FOUND</code>. </p>
<p>Opening a file-system resource would be one of the errors  <code>ENODEV</code>,  <code>ENOENT</code>, or  <code>ENOTDIR</code><sup class="footnote-reference"><a href="#1">1</a></sup>.
</dd>
<dt id="ERR_INVALID_INPUT_RESOURCE">ERR_INVALID_INPUT_RESOURCE</dt>
<dd></p>
<p>The resource was retrieved, but it was not possible to parse it according to its expected media type.
</dd>
<dt id="ERR_OUTPUT_RESOURCE_NOT_WRITEABLE">ERR_OUTPUT_RESOURCE_NOT_WRITEABLE</dt>
<dd></p>
<p>An <code>output</code> processing instruction identified a resource but the relation could not be written to that resource.
</dd>
<dt id="ERR_IO_INSTRUCTION_PARAMETER">ERR_IO_INSTRUCTION_PARAMETER</dt>
<dd></p>
<p>A parameter specified for an input or output processing instruction does not match the expectations of the media type, or does not match the relation’s schema.
</dd>
<dt id="ERR_IO_SYSTEM_FAILURE">ERR_IO_SYSTEM_FAILURE</dt>
<dd></p>
<p>The underlying input output system reported a failure. For <code>file</code> URIs this is typically file system errors, for <code>http</code> this would be HTTP, <span class="bibref inline"><a href="vnd_datalog_text/x_references.html#RFC2616">RFC2616</a></span> <a href="https://datatracker.ietf.org/doc/html/rfc2616#section-10">§ 10. Status Code Definitions</a>, or network errors.
</dd></p>
</dl>
<h2 id="evaluator-errors"><a class="header" href="#evaluator-errors">Evaluator Errors</a></h2>
<p><em>This section is non-normative.</em></p>
<p>The following errors are introduced for use by the <em>evaluator</em> subcomponent of the DATALOG-TEXT processor. This section is non-normative because this specification does not address any behavior required of the evaluator. It is included here because in some cases a parser may choose to perform more detailed semantic evaluation of rules which would result in these errors.</p>
<dl class="enum">
    <dt id="ERR_NOT_EVALUABLE">ERR_NOT_EVALUABLE</dt>
    <dd>
<p>The parsed and resolved resource cannot be evaluated, this is generally a catch-all error when the parsed resource semantics are unclear or contradictory.
</dd>
<dt id="ERR_INCOMPATIBLE_RELATION_SCHEMA">ERR_INCOMPATIBLE_RELATION_SCHEMA</dt>
<dd></p>
<p>This error occurs when evaluating rules where the required operation two or more relations (union, intersection, cartesian product, join, …) cannot be performed as the relations have incompatible schema.
</dd></p>
</dl>
<h2 id="with-negation"><a class="header" href="#with-negation">With Negation</a></h2>
<dl class="enum">
    <dt id="ERR_NEGATIVE_VARIABLE_NOT_IN_POSITIVE_RELATIONAL_LITERAL">ERR_NEGATIVE_VARIABLE_NOT_IN_POSITIVE_RELATIONAL_LITERAL</dt>
    <dd>
<p>A variable that is used within a negated literal does not also appear in a positive <em>relational</em> literal. For example, the following is invalid: <code>a(X) :- b(Y), NOT b(X).</code>
</dd></p>
</dl>
<h2 id="with-arithmetic-literals"><a class="header" href="#with-arithmetic-literals">With Arithmetic Literals</a></h2>
<dl class="enum">
    <dt id="ERR_ARITHMETIC_VARIABLE_NOT_IN_POSITIVE_RELATIONAL_LITERAL">ERR_ARITHMETIC_VARIABLE_NOT_IN_POSITIVE_RELATIONAL_LITERAL</dt>
    <dd>
<p>A variable that is used within an arithmetic literal does not also appear in a positive <em>relational</em> literal. For example, the following is invalid: <code>a(X) :- b(Y), X &lt; Y.</code>
</dd>
<dt id="ERR_INVALID_OPERATOR_FOR_TYPE">ERR_INVALID_OPERATOR_FOR_TYPE</dt>
<dd></p>
<p>The operator is not specified for the type of the current entity.
</dd>
<dt id="ERR_INCOMPATIBLE_TYPES_FOR_OPERATOR">ERR_INCOMPATIBLE_TYPES_FOR_OPERATOR</dt>
<dd></p>
<p>The left-hand and right-hand sides of the literal are of different types and the operator cannot be used with the combination of types.
</dd>
<dt id="WARN_ARITHMETIC_LITERAL_IS_ALWAYS_TRUE">WARN_ARITHMETIC_LITERAL_IS_ALWAYS_TRUE</dt>
<dd></p>
<p>Evaluation of this literal will always return true. For example <code>1 = 1</code>.
</dd>
<dt id="WARN_ARITHMETIC_LITERAL_IS_ALWAYS_FALSE">WARN_ARITHMETIC_LITERAL_IS_ALWAYS_FALSE</dt>
<dd></p>
<p>Evaluation of this literal will always return false. For example <code>1 = 2</code>
</dd></p>
</dl>
<h2 id="with-constraints"><a class="header" href="#with-constraints">With Constraints</a></h2>
<p>The error <code>ERR_INVALID_NUMBER_OF_ATOMS_IN_HEAD</code> is relaxed in $\small\text{Datalog}^{\Leftarrow}$ to allow zero atoms in a rule’s head.</p>
<h2 id="with-disjunction"><a class="header" href="#with-disjunction">With Disjunction</a></h2>
<p>The error <code>ERR_INVALID_NUMBER_OF_ATOMS_IN_HEAD</code> is relaxed in $\small\text{Datalog}^{\lor}$ to allow more than one atom in a rule’s head.</p>
<h2 id="with-functional-dependenciesio"><a class="header" href="#with-functional-dependenciesio">With Functional Dependencies/IO</a></h2>
<pre><code class="language-datalog">.assert employee(ein: integer, name: string, ssn: string, active: bool).
.fd employee: ein --&gt; ssn.
.fd employee: ein --&gt; 2, 4. 
</code></pre>
<dl class="enum">
    <dt id="ERR_INVALID_ATTRIBUTE_INDEX">ERR_INVALID_ATTRIBUTE_INDEX</dt>
    <dd>
<p>The integer index in the functional dependency specification is not a valid attribute index in the relation.</p>
<p>For example, in <code>.fd employee: employee_id --&gt; ssn.</code> the attribute label
<code>employee_id</code> is invalid.</p>
<p>This error is also used to denote invalid columns specified in <code>input</code> or
<code>output</code> processing instructions.
</dd>
<dt id="ERR_INVALID_ATTRIBUTE_LABEL">ERR_INVALID_ATTRIBUTE_LABEL</dt>
<dd></p>
<p>The predicate in the functional dependency specification is not a valid attribute label in the relation.</p>
<p>For example, in <code>.fd employee: ein --&gt; 2, 24.</code> the index <code>24</code> is invalid.</p>
<p>This error is also used to denote invalid columns specified in <code>input</code> or
<code>output</code> processing instructions.
</dd></p>
</dl>
<p>The error <code>ERR_PREDICATE_NOT_AN_EXTENSIONAL_RELATION</code> is raised if the relation predicate in the processing instruction has not been asserted as an extensional relation.</p>
<h2 id="error-type"><a class="header" href="#error-type">Error Type</a></h2>
<p><em>This section is non-normative.</em></p>
<p>This specification assumes the presence of a type that allows the instance of a signaled error to carry information regarding the location of the error and any other relevant context. The following is a non-normative structure that may be referenced by this specification.</p>
<pre><code class="language-text">structure Error {
    kind: ErrorKind,
    caused_by: Option&lt;Error&gt;,
    source_line: Option&lt;integer&gt;,
    source_column: Option&lt;integer&gt;,
    message: string,
}
</code></pre>
<ul>
<li><code>kind</code> – the error identifier.</li>
<li><code>caused_by</code> – an optional inner value allowing error instances to be nested.</li>
<li><code>source_line</code> – where possible the parser should identify the 1-based line number where the error occurred.</li>
<li><code>source_column</code> – where possible the parser should identify the 1-based column number where the error occurred.</li>
<li><code>message</code> – a string providing as much information as possible regarding this error instance including any labels associated with values in error.</li>
</ul>
<p>The above structure required a type <code>ErrorKind</code>, this is the enumeration of all the error identifiers from the section above.</p>
<pre><code class="language-text">enumeration ErrorKind {
    ERR_UNSUPPORTED_DIALECT,
    …
}
</code></pre>
<p>&nbsp;</p>
<hr />
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>From The Open Group <a href="https://pubs.opengroup.org/onlinepubs/9699919799/functions/open.html">man page</a> for the <code>open()</code> function.</p>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="security-considerations"><a class="header" href="#security-considerations">Security Considerations</a></h1>
<p>See, Security Considerations in <a href="vnd_datalog_text/x_iana.html">IANA Considerations</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="appendix-internationalization-considerations"><a class="header" href="#appendix-internationalization-considerations">Appendix: Internationalization Considerations</a></h1>
<p>Unicode provides a mechanism for signaling direction within a string (see <a href="https://www.unicode.org/reports/tr9/tr9-42.html">Unicode Bidirectional Algorithm</a> <span class="bibref inline"><a href="vnd_datalog_text/x_references.html#UAX9">UAX9</a></span>), however, when a string has an overall base direction which cannot be determined by the beginning of the string, an external indicator is required, such as the <span class="bibref inline"><a href="vnd_datalog_text/x_references.html#HTML">HTML</a></span> <code>dir</code> attribute, which currently has no counterpart for Datalog literals.</p>
<p>Until a more comprehensive solution can be addressed in a future version of this specification, programmers should consider this issue when representing strings where the base direction of the string cannot otherwise be correctly inferred based on the content of the string. See <span class="bibref inline"><a href="vnd_datalog_text/x_references.html#string-meta">string-meta</a></span> for a discussion best practices for identifying language and base direction for strings used on the Web.</p>
<h2 id="identifier-characters"><a class="header" href="#identifier-characters">Identifier Characters</a></h2>
<p>The characters allowed in labeling relations, attributes, facts, atoms, and variables are taken from a broad set of Unicode by category rather than by codepoint range. The following are the definitions of the lexical productions, showing their relation to defined categories:</p>
<pre><code class="language-ebnf">SPACE_SEP
        ::= ? corresponds to the Unicode category 'Zs' ? ;
LC_ALPHA
        ::= ? corresponds to the Unicode category 'Ll' ? ;
UC_ALPHA
        ::= ? corresponds to the Unicode category 'Lu' ? ;
TC_ALPHA
        ::= ? corresponds to the Unicode category 'Lt' ? ;
ALPHA   ::= LC_ALPHA | UC_ALPHA | TC_ALPHA ;
</code></pre>
<p>The following productions are the key <em>identifier</em>-like values, built almost entirely from the character productions above with the addition of the single “_” underscore.</p>
<pre><code class="language-ebnf">predicate
        ::= LC_ALPHA  ( ALPHA | DIGIT | &quot;_&quot; )* ;
named-variable
        ::= UC_ALPHA  ( ALPHA | DIGIT | &quot;_&quot; )* ;
identifier-string
        ::= predicate ( &quot;:&quot; ALPHA ( ALPHA | DIGIT | &quot;_&quot; )* )? ;
</code></pre>
<h3 id="example-10"><a class="header" href="#example-10">Example</a></h3>
<p>The following is a perfectly valid version of the Socratic syllogism from the example in <a href="vnd_datalog_text/grammar_program.html">§ Program</a>.</p>
<pre><code class="language-datalog">ανθρώπινο(&quot;Σωκράτης&quot;).

θνητός(Χ) :- ανθρώπινο(Χ).

?- θνητός(&quot;Σωκράτης&quot;).
</code></pre>
<h2 id="numerical-values"><a class="header" href="#numerical-values">Numerical Values</a></h2>
<p>Numerical values use the following lexical production that allows a number of language representations of the digits 0 to 9. For example, “123”, “١٢٣” (Arabic-Indic), or “१२३” (Devangari).</p>
<pre><code class="language-ebnf">DIGIT   ::= ? corresponds to the Unicode category 'Nd' (decimal number) ? ;
</code></pre>
<p>The only exception to this broad inclusive approach is the definition of the <code>HEXDIGIT</code> production where the Anglo-centric approach is commonly understood and alternate forms may cause confusion.</p>
<pre><code class="language-ebnf">HEXDIGIT
        ::= [0-9a-fA-F] ;
</code></pre>
<h2 id="unicode-operators"><a class="header" href="#unicode-operators">Unicode Operators</a></h2>
<p>The following operators, or syntax symbols, are defined in this specification. Where Unicode symbols are defined for the symbol these are described by codepoint value and assigned name.</p>
<table><thead><tr><th>Symbol</th><th>Primary</th><th>Alternate</th><th>Unicode</th><th>Codepoint</th><th>Name</th></tr></thead><tbody>
<tr><td>Material implication</td><td><code>:-</code></td><td><code>&lt;-</code></td><td><code>←</code></td><td>U+E28690</td><td>LEFTWARDS ARROW</td></tr>
<tr><td>Conjunction</td><td><code>,</code></td><td><code>&amp;</code>, <code>AND</code></td><td><code>∧</code></td><td>U+E288A7</td><td>LOGICAL AND</td></tr>
<tr><td>True (boolean)</td><td><code>true</code></td><td></td><td><code>⊤</code></td><td>U+E28AA4</td><td>DOWN TACK</td></tr>
<tr><td>False (boolean)</td><td><code>false</code></td><td></td><td><code>⊥</code></td><td>U+E28AA5</td><td>UP TACK</td></tr>
<tr><td>Logical negation</td><td><code>!</code></td><td><code>NOT</code></td><td><code>￢</code></td><td>U+EFBFA2</td><td>FULLWIDTH NOT SIGN</td></tr>
<tr><td>Disjunction</td><td><code>;</code></td><td><code>|</code>, <code>OR</code></td><td><code>∨</code></td><td>U+E2BBA8</td><td>LOGICAL OR</td></tr>
<tr><td>Tautology</td><td>N/A</td><td></td><td><code>⊤</code></td><td>U+E28AA4</td><td>DOWN TACK</td></tr>
<tr><td>Absurdity</td><td></td><td></td><td><code>⊥</code></td><td>U+E28AA5</td><td>UP TACK</td></tr>
<tr><td>Equal</td><td><code>=</code></td><td></td><td></td><td>U+3D</td><td>EQUALS SIGN</td></tr>
<tr><td>Not equal</td><td><code>!=</code></td><td><code>/=</code></td><td><code>≠</code></td><td>U+E289A0</td><td>NOT EQUAL TO</td></tr>
<tr><td>Less Than</td><td><code>&lt;</code></td><td></td><td></td><td>U+3C</td><td>LESS-THAN SIGN</td></tr>
<tr><td>Less than, or equal</td><td><code>&lt;=</code></td><td></td><td><code>≤</code></td><td>U+E289A4</td><td>LESS-THAN OR EQUAL TO</td></tr>
<tr><td>Greater than</td><td><code>&gt;</code></td><td></td><td></td><td>U+3E</td><td>GREATER-THAN SIGN</td></tr>
<tr><td>Greater than, or equal</td><td><code>&gt;=</code></td><td></td><td><code>≥</code></td><td>U+E289A5</td><td>GREATER-THAN OR EQUAL TO</td></tr>
<tr><td>String match</td><td><code>*=</code></td><td><code>MATCH</code></td><td><code>≛</code></td><td>U+E2899B</td><td>STAR EQUALS</td></tr>
<tr><td>Functional dependency</td><td><code>--&gt;</code></td><td></td><td><code>⟶</code></td><td>U+E29FB6</td><td>LONG RIGHTWARDS ARROW</td></tr>
</tbody></table>
<p>The following table describes the symbols introduced by different Datalog languages. Note that only the symbols material implication, conjunction, true, and false, are required by the core language $\small\text{Datalog}$.</p>
<table><thead><tr><th>Language</th><th>Introduces</th><th>Symbols</th></tr></thead><tbody>
<tr><td>$\small\text{Datalog}^{\lnot}$</td><td>negation of literals in rule bodies</td><td><code>!</code>, <code>NOT</code>, <code>￢</code></td></tr>
<tr><td>$\small\text{Datalog}^{\lor}$</td><td>disjunction in rule heads</td><td><code>;</code>, <code>|</code>, <code>OR</code>, <code>∨</code></td></tr>
<tr><td>$\small\text{Datalog}^{\Leftarrow}$</td><td>rules as constraints, i.e. no body</td><td><code>⊤</code></td></tr>
<tr><td>$\small\text{Datalog}^{\Gamma}$</td><td>typed attributes for relations</td><td>N/A</td></tr>
<tr><td>$\small\text{Datalog}^{\theta}$</td><td>arithmetic literals in rule bodies</td><td><code>=</code>, <code>!=</code>, <code>≠</code>, &lt;<code>, </code>&lt;=<code>, </code>≤<code>, </code>&gt;<code>, </code>&gt;=<code>, </code>≥<code>, </code>*=<code>, </code>≛`</td></tr>
<tr><td>$\small\text{Datalog}^{\rightarrow}$</td><td>functional dependency processing instruction</td><td><code>--&gt;</code>, <code>⟶</code></td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h1 id="appendix-ebnf"><a class="header" href="#appendix-ebnf">Appendix: EBNF</a></h1>
<p>The EBNF used here is defined in XML 1.0 <span class="bibref inline"><a href="vnd_datalog_text/x_references.html#EBNF-NOTATION">EBNF-NOTATION</a></span> with the addition that each rule in the grammar ends with a semicolon character <code>;</code>.</p>
<pre><code class="language-ebnf">program ::= processing-instruction* ( fact | rule | query )* ;

/* ************************************************************************* */

fact    ::= assertion | retraction ;

assertion
        ::= fact-body &quot;.&quot; ;

retraction
        ::= fact-body &quot;~&quot; ;

fact-body
        ::= predicate ( &quot;(&quot; constant ( &quot;,&quot; constant )* &quot;)&quot; )? ;
        
predicate
        ::= LC_ALPHA ( ALPHA | DIGIT | UNDERSCORE )* ;

/* ************************************************************************* */

constant
        ::= string | number | boolean ;

string  ::= identifier-string | literal-string ;

identifier-string
        ::= predicate ( &quot;:&quot; ALPHA ( ALPHA | DIGIT | UNDERSCORE )* )? ;

literal-string
        ::= DQUOTE ( string-escape | [^#x22] )* DQUOTE ;

string-escape
        ::= &quot;\\&quot; ( DQUOTE | [tnr] )
        | &quot;\u{&quot; HEXDIGIT HEXDIGIT HEXDIGIT HEXDIGIT
              ( HEXDIGIT HEXDIGIT HEXDIGIT HEXDIGIT )? &quot;}&quot; ;

number  ::= float   # Optional
        | decimal   # Optional
        | integer ; # Required

integer ::= ( &quot;+&quot; | &quot;-&quot; )? DIGIT+ ;

decimal ::= integer &quot;.&quot; DIGIT+ ;

float   ::= ( decimal ( &quot;e&quot; | &quot;E&quot; ) integer )
            | &quot;+inf.0&quot;
            | &quot;-inf.0&quot;
            | &quot;+nan.0&quot; ;

boolean ::= &quot;true&quot; | &quot;false&quot; ;

/* ************************************************************************* */

rule    ::= head? ( &quot;:-&quot; | &quot;&lt;-&quot; | &quot;⟵&quot; ) body &quot;.&quot; ;

head    ::= ( atom ( ( &quot;;&quot; | &quot;|&quot; | &quot;OR&quot; | &quot;∨&quot; ) atom )* )
            | &quot;⊥&quot; ;

body    ::= literal ( ( &quot;,&quot; | &quot;&amp;&quot; | &quot;AND&quot; | &quot;∧&quot; ) literal )* ;

/* ************************************************************************* */

atom    ::= predicate &quot;(&quot; term ( &quot;,&quot; term )* &quot;)&quot; ;

term    ::= variable | constant ;

variable
        ::= named-variable | anon-variable ;

named-variable
        ::= UC_ALPHA ( ALPHA | DIGIT | UNDERSCORE )* ;

anon-variable
        ::= UNDERSCORE ;

/* ************************************************************************* */

literal ::= ( &quot;!&quot; | &quot;NOT&quot; | &quot;￢&quot; )?
            ( relational-literal
            | arithmetic-literal ) ;

/* ************************************************************************* */

relational-literal
        ::= atom ;

arithmetic-literal
        ::= operand operator operand ;

operand ::= ( named-variable | constant ) ;

operator
        ::= &quot;=&quot;
            | (&quot;!=&quot; | &quot;/=&quot; | &quot;≠&quot;)
            | &quot;&lt;&quot;
            | (&quot;&lt;=&quot; | &quot;≤&quot;)
            | &quot;&gt;&quot;
            | (&quot;&gt;=&quot; | &quot;≥&quot;)
            | (&quot;*=&quot; | &quot;≛&quot; | &quot;MATCHES&quot;) ;

/* ************************************************************************* */

query   ::= ( &quot;?-&quot; atom &quot;.&quot; )
        |   ( atom &quot;?&quot; ) ;

/* ************************************************************************* */

processing-instruction
        ::= &quot;.&quot;
            ( pi-pragma
            | pi-assert
            | pi-infer
            | pi-input
            | pi-output )
            &quot;.&quot; ;

pi-pragma
        ::= &quot;pragma&quot; predicate ( &quot;=&quot; constant )? ;

pi-assert
        ::= &quot;assert&quot; relation-decl functional-dependency-list? ;

relation-decl
        ::= predicate attribute-decl-list ;

attribute-decl-list
        ::= &quot;(&quot; attribute-decl ( &quot;,&quot; attribute-decl )* &quot;)&quot; ;

attribute-decl
        ::= ( predicate &quot;:&quot; )?
            ( &quot;boolean&quot; | &quot;float&quot; | &quot;decimal&quot; | &quot;integer&quot; | &quot;string&quot; ) ;

functional-dependency-list
        ::= &quot;:&quot; functional-dependency ( &quot;;&quot; functional-dependency )* ;

functional-dependency
        ::= attribute-index-list ( &quot;--&gt;&quot; | &quot;⟶&quot; ) attribute-index-list ;

attribute-index-list
        ::= attribute-index ( &quot;,&quot; attribute-index )* ;

attribute-index
        ::= integer | predicate ;

pi-infer
        ::= &quot;infer&quot; ( relation-decl | &quot;from&quot; predicate ) ;

pi-input
        ::= &quot;input&quot; io-details ;

io-details
        ::= predicate parameter-list ;

parameter-list
        ::= &quot;(&quot; parameter-assignment ( &quot;,&quot; parameter-assignment )* &quot;)&quot; ;

parameter-assignment
        ::= predicate &quot;=&quot; constant ;

/*
Known Parameter types:

uri     ::=  URI ;
type    ::=  predicate | media-type ;
headers ::= &quot;present&quot; | &quot;absent&quot; ;
columns ::= column ( &quot;,&quot; column )* ;
column  ::= integer |
            &quot;[&quot; integer? &quot;:&quot; integer? &quot;]&quot; ;
table   ::= identifier-string ;
db-columns
        ::= identifier-string ( &quot;,&quot; identifier-string )* ;
*/

pi-output
        ::= &quot;output&quot; parameter-list ;

/* ************************************************************************* */

comment ::= line-comment | block-comment ;

line-comment
        ::= &quot;%&quot; [^\r\n]* EOL ;

block-comment
        ::= '/*' ( [^*] | '*'+ [^*/] )* '*'* '*/' ;

/* ************************************************************************* */

EOL     ::= &quot;\n&quot; | &quot;\r&quot; &quot;\n&quot;? ;

DQUOTE  ::= #x22 ;

UNDERSCORE
        ::= &quot;_&quot; ;

SPACE_SEP
        ::= ? corresponds to the Unicode category 'Zs' ? ;

WHITESPACE
        ::= SPACE_SEP | &quot;\t&quot; | EOL ;

LC_ALPHA
        ::= ? corresponds to the Unicode category 'Ll' ? ;

UC_ALPHA
        ::= ? corresponds to the Unicode category 'Lu' ? ;

TC_ALPHA
        ::= ? corresponds to the Unicode category 'Lt' ? ;

ALPHA   ::= LC_ALPHA | UC_ALPHA | TC_ALPHA ;

DIGIT   ::= ? corresponds to the Unicode category 'Nd' (decimal number) ? ;

HEXDIGIT
        ::= [0-9a-fA-F] ;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="appendix-result-formats"><a class="header" href="#appendix-result-formats">Appendix: Result Formats</a></h1>
<p>A DATALOG-TEXT processor may simply need to return query results via an API
and so not deal with the display of data to human users. If the processor does
display human-readable results it should be done according to the results
formats defined in this section.</p>
<p>If a processor supports multiple result forms, including forms not defined in
this specification, the programmer can select the preferred form via the
<code>results</code> pragma <a href="vnd_datalog_text/pragmas.html#pragma-results">§ Pragma results</a> or some
other means such as processor command-line parameters, environment variables
and so forth.</p>
<h2 id="native-format"><a class="header" href="#native-format"><code>native</code> Format</a></h2>
<p>This format MUST be supported by a conforming DATALOG-TEXT processor that displays results in human-readable form</p>
<h3 id="example--existential-query"><a class="header" href="#example--existential-query">Example – Existential Query</a></h3>
<pre><code class="language-datalog">.pragma results=native
?- mortal(&quot;Socrates&quot;).
</code></pre>
<p>In the native results form a processor MAY return the matching fact, or return
a boolean response. The two results in the following example are therefore equivalent:</p>
<pre><code class="language-datalog">mortal(&quot;Socrates&quot;).
true
</code></pre>
<h3 id="example--selection-query"><a class="header" href="#example--selection-query">Example – Selection Query</a></h3>
<pre><code class="language-datalog">.pragma results=native
?- mortal(X).
</code></pre>
<p>As above, but the output MUST be line-oriented with a single fact per line.</p>
<pre><code class="language-datalog">mortal(&quot;Socrates&quot;).
mortal(&quot;Plato&quot;).
</code></pre>
<h3 id="example--projection-query"><a class="header" href="#example--projection-query">Example – Projection Query</a></h3>
<pre><code class="language-datalog">.pragma results=native
.assert car(make: string, model: string, age: integer).

car(&quot;ford&quot;, X, _)?
</code></pre>
<p>As above, but only variables are REQUIRED to be included in the response.
Specifically, anonymous attributes MUST be removed from the results and the
inclusion of constant values MAY be present, but it is RECOMMENDED to remove
them.</p>
<p>In the native form the result <code>car(edge).</code> would be an error as the car relation has
three attributes; similarly, <code>car(&quot;ford&quot;, edge, _).</code> is invalid as it includes
an anonymous variable in a fact. The naïve approach is to return the entirety
of the matching facts, as shown below. However, this results in a column that
was specifically anonymous and really should not be present.</p>
<pre><code class="language-datalog">car(&quot;ford&quot;, edge, 22).
car(&quot;ford&quot;, escort, 12).
car(&quot;ford&quot;, fiesta, 8).
car(&quot;ford&quot;, focus, 19).
car(&quot;ford&quot;, fusion, 13).
car(&quot;ford&quot;, mustang, 3).
…
</code></pre>
<p>In this case the processor MAY choose to construct a new intensional relation
representing the query and then return these <em>simplified</em> facts.</p>
<pre><code class="language-datalog">car_1 :- car(&quot;ford&quot;, X, _).

car_1(edge).
car_1(escort).
car_1(fiesta).
car_1(focus).
car_1(fusion).
car_1(mustang).
…
</code></pre>
<h2 id="tabular-format"><a class="header" href="#tabular-format"><code>tabular</code> Format</a></h2>
<p>This format is optional but RECOMMENDED.</p>
<p>This specification does not require a specific set of characters for laying
out tables. The following are all acceptable styles that use either ASCII
characters or Unicode Box Drawing characters. Note that all the formats below
do make a distinction between header and body rows.</p>
<pre><code class="language-text">+------------+------------+    ,------------+------------,    
| X: string  | Y: string  |    | X: string  | Y: string  |    X: string  | Y: string
+============+============+    |============+============|    -----------+-----------
| &quot;Socrates&quot; | &quot;Plato&quot;    |    | &quot;Socrates&quot; | &quot;Plato&quot;    |    &quot;Socrates&quot; | &quot;Plato&quot;    
+------------+------------+    '------------+------------'    

┌────────────┬────────────┐    ╭────────────┬────────────╮    
│ X: String  │ Y: String  │    │ X: String  │ Y: String  │    X: String  │ Y: String 
╞════════════╪════════════╡    ╞════════════╪════════════╡    ═══════════╪═══════════
│ &quot;Socrates&quot; │ &quot;Plato&quot;    │    │ &quot;Socrates&quot; │ &quot;Plato&quot;    │    &quot;Socrates&quot; │ &quot;Plato&quot;   
└────────────┴────────────┘    ╰────────────┴────────────╯    
</code></pre>
<h3 id="example--existential-query-1"><a class="header" href="#example--existential-query-1">Example – Existential Query</a></h3>
<p>In the fact result form a table has an unnamed column with the fact constants
included.</p>
<pre><code class="language-text">+------------+
| _: string  |
+============+
| &quot;Socrates&quot; |
+------------+
</code></pre>
<p>In the boolean result form a table is written with an unlabeled column with
the value <code>true</code>.</p>
<pre><code class="language-text">+------------+
| _: boolean |
+============+
| true       |
+------------+
</code></pre>
<h3 id="example--selection-query-1"><a class="header" href="#example--selection-query-1">Example – Selection Query</a></h3>
<p>In the tabular results form a table is written with one column per variable in
the goal and all matching facts as rows. </p>
<pre><code class="language-text">+------------+
| X: string  |
+============+
| &quot;Socrates&quot; |
| &quot;Plato&quot;    |
+------------+
</code></pre>
<p>Note that in naming a column it is appropriate to use either the name of the
variable (as shown above) or the name of the attribute if known (below).</p>
<pre><code class="language-text">+---------------+
| name: string  |
+===============+
| &quot;Socrates&quot;    |
| &quot;Plato&quot;       |
+---------------+
</code></pre>
<h3 id="example--projection-query-1"><a class="header" href="#example--projection-query-1">Example – Projection Query</a></h3>
<p>As above.</p>
<pre><code class="language-text">+------------+
| X: string  |
+============+
| edge       |
+------------+
| escort     |
+------------+
| fiesta     |
+------------+
| focus      |
+------------+
| fusion     |
+------------+
| mustang    |
+------------+
      …
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="appendix-iana-considerations"><a class="header" href="#appendix-iana-considerations">Appendix: IANA Considerations</a></h1>
<p>This section has been submitted to the Internet Engineering Steering Group (IESG)<sup class="footnote-reference"><a href="#1">1</a></sup> for review, approval, and registration with IANA<sup class="footnote-reference"><a href="#2">2</a></sup>.</p>
<h2 id="applicationvnddatalog"><a class="header" href="#applicationvnddatalog">application/vnd.datalog</a></h2>
<dl>
    <dt>Type name:</dt>
    <dd><code>application</code></dd>
    <dt>Subtype name:</dt>
    <dd><code>vnd.datalog</code></dd>
    <dt>Required parameters:</dt>
    <dd>None.</dd>
    <dt>Optional parameters:</dt>
    <dd>
<p><code>features</code></p>
<p>The optional “features” parameter allows the transport to identify language features
used within the representation. The value of this parameter is a
comma-separated list of feature identifiers supported by the specification.
Feature identifiers conform to the following EBNF production.</p>
<pre><code>id ::= LC_ALPHA ( ALPHA | DIGIT | UNDERSCORE )* ;
</code></pre>
<p>The purpose of this parameter is to save a client from having to parse a
document if the features identified in the parameter are unsupported by them.
If this parameter is specified more than once its values MUST be aggregated
into a set, removing duplicates.</p>
<p><code>dialect</code></p>
<p>The “dialect” parameter identifies the tool which generated the document,
there are some existing tools with extensive usage that deviate from this core
specification. Dialect identifiers conform to the same <code>id</code> production
described for feature identifiers.</p>
<p>If this parameter is specified more than once, the first value MUST be used
and any subsequent value MUST be discarded.
</dd>
<dt>Encoding considerations:</dt>
<dd>The content encoding of a Datalog text document is always UTF-8.</dd>
<dt>Security considerations:</dt>
<dd>
This media type does include program code for a Datalog interpreter to
execute. However, as Datalog is a restricted deductive logic language
its execution environment is limited to entailment and query, and not
capable of general purpose programming.</p>
<p>The Datalog language does contain references to additional resources
that may be required to complete a program. For example, an “input”
processing instruction will add facts from an external resource (using
IRIs) to an extensional relation whereas the “output” processing
instruction will be some local resource that may be written to. The
ability to include malicious data in an input file is limited by the
supported representations such as CSV. The ability to write to a local
system may be intercepted by a parser to redirect to safe locations,
and as such the allowed reference is always relative.</p>
<p>This media type requires no privacy or integrity services.
</dd>
<dt>Interoperability considerations:</dt>
<dd>
A number of vendors have extended Datalog with additional syntax, this has been
a general problem for some years. The introduction of a common standard, and
support for the “dialect” parameter will help clients understand the potential
parsing issues of a specific document.
</dd>
<dt>Intended usage:</dt>
<dd>Common – For the interchange of Datalog programs.</dd>
<dt>Applications which use this media:</dt>
<dd>Applications that need to upload, download, or transfer Datalog programs.</dd>
<dt>Fragment identifier considerations:</dt>
<dd>None.</dd>
<dt>Restrictions on usage:</dt>
<dd>None.</dd>
<dt>Published specification:</dt>
<dd>
<a href="https://datalog-specs.info/vnd_datalog_text/abstract.html">https://datalog-specs.info/vnd_datalog_text/abstract.html</a>.
</dd>
<dt>Additional information:</dt>
<dd>
<dl>
<dt>Magic number(s):</dt>
<dd>None.</dd>
<dt>File extension(s):</dt>
<dd>dl</dd>
<dt>Macintosh file type code:</dt>
<dd>TEXT</dd>
</dl>
</dd>
<dt>General Comments:</dt>
<dd>None.</dd>
<dt>Provisional registration? (standards tree only):</dt>
<dd>N/A</dd>
<dt>Author/Change controller:</dt>
<dd>N/A</dd></p>
</dl>
<p>&nbsp;</p>
<hr />
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>See <a href="https://www.ietf.org/about/groups/iesg/">https://www.ietf.org/about/groups/iesg/</a>.</p>
</div>
<div class="footnote-definition" id="2"><sup class="footnote-definition-label">2</sup>
<p>According to <span class="bibref inline"><a href="vnd_datalog_text/x_references.html#RFC1590">RFC1590</a></span>, and <a href="https://www.iana.org/form/media-types">Application for a Media Type</a>.</p>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="appendix-references"><a class="header" href="#appendix-references">Appendix: References</a></h1>
<div class="biblio">
<ol>
<li>
<p><span class="bibkey" id="AbHuVi94">AbHuVi94</span>A. Abiteboul, R. Hull, &amp; V. Vianu. <em>Foundations of Databases: The Logical Level</em>. (Pearson, 1995). URL: <a href="http://webdam.inria.fr/Alice/">webdam.inria.fr/Alice/</a>.</p>
</li>
<li>
<p><span class="bibkey" id="CeGoTa90">CeGoTa90</span>S. Ceri, G. Gottlob, &amp; L. Tanca. <em>Logic Programming and Databases</em>. (Springer Berlin Heidelberg, 1990). DOI: <a href="https://link.springer.com/book/10.1007/978-3-642-83952-8">10.1007/978-3-642-83952-8</a>.</p>
</li>
<li>
<p><span class="bibkey" id="EBNF-NOTATION">EBNF-NOTATION</span>T. Bray, J. Paoli. C. M. Sperberg-McQueen, E. Maler, F. Yergeau. <em>EBNF Notation</em> 26 November 2008. W3C Recommendation. URL: <a href="http://www.w3.org/TR/REC-xml/#sec-notation">http://www.w3.org/TR/REC-xml/#sec-notation</a></p>
</li>
<li>
<p><span class="bibkey" id="ECMA-JSON">ECMA-JSON</span>ECMA International. <em>The JSON Data
Interchange Syntax</em> 2nd Edition. December 2017. URL: <a href="https://www.ecma-international.org/publications-and-standards/standards/ecma-404/">https://www.ecma-international.org/publications-and-standards/standards/ecma-404/</a></p>
</li>
<li>
<p><span class="bibkey" id="Hodg97">Hodg97</span>W. Hodges. <em>A Shorter Model Theory</em>. 1997. Cambridge University Press, USA.</p>
</li>
<li>
<p><span class="bibkey" id="HTML">HTML</span>A. van Kesteren, D. Denicola, I. Hickson, P. Jägenstedt, S. Pieters. <em>HTML Standard</em>. WHATWG. Living Standard. URL: <a href="https://html.spec.whatwg.org/multipage/">https://html.spec.whatwg.org/multipage/</a></p>
</li>
<li>
<p><span class="bibkey" id="IANA-TSV">IANA-TSV</span>P. Lindner. <em>Media Type Registration: text/tab-separated-values</em>. U of MN Internet Gopher Team. URL: <a href="https://www.iana.org/assignments/media-types/text/tab-separated-values">https://www.iana.org/assignments/media-types/text/tab-separated-values</a> </p>
</li>
<li>
<p><span class="bibkey" id="IANA-SQLITE3">IANA-SQLITE3</span>C. Ladisch.
<em>Media Type Registration: application/vnd.sqlite3</em>. URL: <a href="https://www.iana.org/assignments/media-types/application/vnd.sqlite3">https://www.iana.org/assignments/media-types/application/vnd.sqlite3</a> </p>
</li>
<li>
<p><span class="bibkey" id="IEEE754">IEEE754</span><em>IEEE Standard for Binary Floating-Point Arithmetic</em>. 1985. IEEE. URL: <a href="https://standards.ieee.org/ieee/754/993/">https://standards.ieee.org/ieee/754/993/</a>.</p>
</li>
<li>
<p><span class="bibkey" id="Mill1851">Mill1851</span>Mill, J. S. <em>A System of Logic, Ratiocinative and Inductive, Being a Connected View of the Principles of Evidence, and the Methods of Scientific Investigation</em>. 1851. John W. Parker.</p>
</li>
<li>
<p><span class="bibkey" id="R7RS">R7RS</span>Shinn, A., Cowan, J., Glecker, A. A. (editors). <em>Revised7 Reports on the Algorithmic Language Scheme</em>. July 6 2013. URL: <a href="https://small.r7rs.org/attachment/r7rs.pdf">https://small.r7rs.org/attachment/r7rs.pdf</a></p>
</li>
<li>
<p><span class="bibkey" id="RFC1590">RFC1590</span>J. Postel. <em>Media Type Registration Procedure</em>, November 1996. IETF. Internet Standard. URL: <a href="https://tools.ietf.org/html/rfc1590">https://tools.ietf.org/html/rfc1590</a></p>
</li>
<li>
<p><span class="bibkey" id="RFC2119">RFC2119</span>S. Bradner. <em>Key words for use in RFCs to Indicate Requirement Levels</em>. March 1997. IETF. Best Current Practice. URL: <a href="https://tools.ietf.org/html/rfc2119">https://tools.ietf.org/html/rfc2119</a></p>
</li>
<li>
<p><span class="bibkey" id="RFC2616">RFC2616</span>R. Fielding, J. Gettys, J. Mogul, H. Frystyk, L. Masinter, P. Leach, and T. Berners-Lee. <em>Hypertext Transfer Protocol – HTTP/1.1</em>. June 1999. IETF. Internet Standard. URL: <a href="https://tools.ietf.org/html/rfc2616">https://tools.ietf.org/html/rfc2616</a></p>
</li>
<li>
<p><span class="bibkey" id="RFC3986">RFC3986</span>T. Berners-Lee, R. Fielding, L. Masinter. <em>Uniform Resource Identifier (URI): Generic Syntax</em>. January 2005. IETF. Internet Standard. URL: <a href="https://tools.ietf.org/html/rfc3986">https://tools.ietf.org/html/rfc3986</a></p>
</li>
<li>
<p><span class="bibkey" id="RFC4180">RFC4180</span>Y. Shafranovich. <em>Common Format and MIME Type for Comma-Separated Values (CSV) Files</em>. October 2005. IETF. Memo. URL: <a href="https://tools.ietf.org/html/rfc4180">https://tools.ietf.org/html/rfc4180</a></p>
</li>
<li>
<p><span class="bibkey" id="RFC4627">RFC4627</span>D. Crockford. <em>The application/json Media Type for JavaScript Object Notation (JSON)</em>. July 2006. IETF. Memo. URL: <a href="https://tools.ietf.org/html/rfc4627">https://tools.ietf.org/html/rfc4627</a></p>
</li>
<li>
<p><span class="bibkey" id="RFC8174">RFC8089</span>M. Kerwin. <em>The “file” URI Scheme</em>. February 2017. IETF. Internet Standard. URL: <a href="https://tools.ietf.org/html/rfc8089">https://tools.ietf.org/html/rfc8089</a></p>
</li>
<li>
<p><span class="bibkey" id="RFC7231">RFC7231</span>R. Fielding, J. Reschke. <em>Hypertext Transfer Protocol (HTTP/1.1): Semantics and Content</em>. June 2014. IETF. Internet Standard. URL: <a href="https://tools.ietf.org/html/rfc7231">https://tools.ietf.org/html/rfc7231</a></p>
</li>
<li>
<p><span class="bibkey" id="RFC8174">RFC8174</span>B. Leiba. <em>Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words</em>. May 2017. IETF. Best Current Practice. URL: <a href="https://tools.ietf.org/html/rfc8174">https://tools.ietf.org/html/rfc8174</a></p>
</li>
<li>
<p><span class="bibkey" id="SQLITE3-URI">SQLITE3-URI</span><em>Uniform Resource Identifiers</em>. URL: <a href="https://www.sqlite.org/uri.html">https://www.sqlite.org/uri.html</a></p>
</li>
<li>
<p><span class="bibkey" id="strings-meta">strings-meta</span>A. Phillips, R. Ishida. <em>Strings on the Web: Language and Direction Metadata</em>. 11 June 2019. W3C. W3C Working Draft. URL: <a href="https://www.w3.org/TR/string-meta/">https://www.w3.org/TR/string-meta/</a></p>
</li>
<li>
<p><span class="bibkey" id="UAX9">UAX9</span>M. Davis, A. Lanin, A. Glass. <em>Unicode Bidirectional Algorithm</em>. 12 February 2020. Unicode Consortium. Unicode Standard Annex #9. URL: <a href="https://www.unicode.org/reports/tr9/tr9-42.html">https://www.unicode.org/reports/tr9/tr9-42.html</a></p>
</li>
<li>
<p><span class="bibkey" id="UNICODE">UNICODE</span><em>The Unicode Standard</em>. URL: <a href="http://www.unicode.org/versions/latest/">http://www.unicode.org/versions/latest/</a></p>
</li>
<li>
<p><span class="bibkey" id="XMLSCHEMA-2">XMLSCHEMA-2</span>Biron, P. V.,  Malhotra A. <em>XML Schema Part 2: Datatypes Second Edition</em>. 28 October 2004. W3C Recommendation. URL: <a href="http://www.w3.org/TR/xmlschema-2/">http://www.w3.org/TR/xmlschema-2/</a>.</p>
</li>
</ol>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="datalog-text-representation--errata"><a class="header" href="#datalog-text-representation--errata">Datalog Text Representation – Errata</a></h1>
<h2 id="version-2-april-2022"><a class="header" href="#version-2-april-2022">Version: 2 April 2022.</a></h2>
<p>None.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="datalog-text-representation--translations"><a class="header" href="#datalog-text-representation--translations">Datalog Text Representation – Translations</a></h1>
<h2 id="version-2-april-2022-1"><a class="header" href="#version-2-april-2022-1">Version: 2 April 2022.</a></h2>
<p>None.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript" src="datalog.js"></script>
        <script type="text/javascript" src="specs.js"></script>
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
    </body>
</html>
