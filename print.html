<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Datalog Specifications</title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
<link   rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.css"
        integrity="sha384-R4558gYOUz8mP9YWpZJjofhk+zx0AS11p36HnD2ZKj/6JR5z27gSSULCNHIRReVs"
        crossorigin="anonymous">
<script defer
        src="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.js"
        integrity="sha384-z1fJDqw8ZApjGO3/unPWUPsIymfsJmyrDVWC8Tv/a1HeOtGmkwNd/7xUS0Xcnvsx"
        crossorigin="anonymous"></script>
<script defer
        src="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/contrib/auto-render.min.js"
        integrity="sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR"
        crossorigin="anonymous"></script>

<script defer>
document.addEventListener("DOMContentLoaded", function() {
    renderMathInElement(document.body, {
        delimiters: [
            {left: "$$", right: "$$", display: true},
            {left: "\\(", right: "\\)", display: false},
            {left: "$", right: "$", display: false},
            {left: "\\[", right: "\\]", display: true}
        ]
    });
});
</script>

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="specs.css">
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="vnd_datalog_text/abstract.html"><strong aria-hidden="true">1.</strong> Datalog Text Representation</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="vnd_datalog_text/introduction.html"><strong aria-hidden="true">1.1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="vnd_datalog_text/conformance.html"><strong aria-hidden="true">1.2.</strong> Conformance</a></li><li class="chapter-item expanded "><a href="vnd_datalog_text/basic_concepts.html"><strong aria-hidden="true">1.3.</strong> Basic Concepts</a></li><li class="chapter-item expanded "><a href="vnd_datalog_text/grammar.html"><strong aria-hidden="true">1.4.</strong> Datalog Document Grammar</a></li><li class="chapter-item expanded "><a href="vnd_datalog_text/datasets.html"><strong aria-hidden="true">1.5.</strong> Dataset Processing</a></li><li class="chapter-item expanded "><a href="vnd_datalog_text/x_ebnf.html"><strong aria-hidden="true">1.6.</strong> Appendix: EBNF</a></li><li class="chapter-item expanded "><a href="vnd_datalog_text/x_international.html"><strong aria-hidden="true">1.7.</strong> Appendix: International Considerations</a></li><li class="chapter-item expanded "><a href="vnd_datalog_text/x_iana.html"><strong aria-hidden="true">1.8.</strong> Appendix: IANA Considerations</a></li><li class="chapter-item expanded "><a href="vnd_datalog_text/x_references.html"><strong aria-hidden="true">1.9.</strong> Appendix: References</a></li><li class="spacer"></li></ol></li><li class="chapter-item expanded "><a href="vnd_datalog_text/z_errata.html"><strong aria-hidden="true">2.</strong> Datalog Text Representation Errata</a></li><li class="chapter-item expanded "><a href="vnd_datalog_text/z_translations.html"><strong aria-hidden="true">3.</strong> Datalog Text Representation Translations</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Datalog Specifications</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://datalog-specs.info" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="datalog-text-representation"><a class="header" href="#datalog-text-representation">Datalog Text Representation</a></h1>
<h2 id="version-xx-march-2022-draft"><a class="header" href="#version-xx-march-2022-draft">Version: XX March 2022 (Draft)</a></h2>
<p>Please check the <a href="vnd_datalog_text/z_errata.html">errata</a> for any errors or issues reported since publication.</p>
<p>The English version of this specification is the only normative version. Non-normative <a href="vnd_datalog_text/z_translations.html">translations</a> may also be available.</p>
<hr />
<h2 id="abstract"><a class="header" href="#abstract">Abstract</a></h2>
<p>This document defines a standard textual representation of a Datalog program. This allows a program to be completely written in a compact and natural text form, with abbreviations for common usage patterns and data-types. </p>
<h2 id="status-of-this-document"><a class="header" href="#status-of-this-document">Status of This Document</a></h2>
<p><em>This section describes the status of this document at the time of its publication. Other documents may supersede this document.</em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<h2 id="how-to-read-this-document"><a class="header" href="#how-to-read-this-document">How to Read This Document</a></h2>
<p><em>This section is non-normative.</em></p>
<p>TBD</p>
<h2 id="contributing"><a class="header" href="#contributing">Contributing</a></h2>
<p><em>This section is non-normative.</em></p>
<p>TBD</p>
<h2 id="terminology"><a class="header" href="#terminology">Terminology</a></h2>
<p><em>This section is non-normative.</em></p>
<ul>
<li><strong>Document</strong> –</li>
<li><strong>Representation</strong> –</li>
<li><strong>Safety</strong> –</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="conformance"><a class="header" href="#conformance">Conformance</a></h1>
<p>As well as sections marked as non-normative, all authoring guidelines, diagrams, examples, and notes in this specification are non-normative. Everything else in this specification is normative.</p>
<p>The keywords <em>MAY</em>, <em>MUST</em>, <em>MUST NOT</em>, <em>RECOMMENDED</em>, <em>SHOULD</em>, and <em>SHOULD NOT</em> in this document are to be interpreted as described in <a href="https://tools.ietf.org/html/bcp14">BCP 14</a> <span class="bibref inline"><a href="vnd_datalog_text/x_references.html#RFC2119">RFC2119</a></span> <span class="bibref inline"><a href="vnd_datalog_text/x_references.html#RFC8174">RFC8174</a></span> when, and only when, they appear in all capitals, as shown here.</p>
<h2 id="media-type-and-content-encoding"><a class="header" href="#media-type-and-content-encoding">Media Type and Content Encoding</a></h2>
<p>The media type of Datalog text document is <code>application/vnd.datalog+text</code>. The content encoding of a Datalog text document is always UTF-8.</p>
<p>The optional “features” parameter allows the transport to identify language features used within the representation. The value of this parameter is a comma-separated list of feature identifiers supported by this specification.</p>
<p>Therefore, the type <code>application/vnd.datalog+text;features=negation</code> denotes a document with the following processing instruction.</p>
<pre><code class="language-datalog">.features(negation).
</code></pre>
<p>The purpose of this parameter is to save a client from having to parse a document if the features identified in the parameter are unsupported by them.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="basic-concepts"><a class="header" href="#basic-concepts">Basic Concepts</a></h1>
<p>A Datalog <strong>Program</strong> $\small P$ is a tuple comprising the <strong>Extensional</strong> database, EDB, or  $\small D_{E}$, the
<strong>Intensional</strong> database, IDB, or  $\small D_{I}$, and a set of queries $\small Q$.</p>
<p>$$\tag{0}\small P=( D_E, D_I, Q )$$</p>
<p>The extensional database in turn is a set of <em>relations</em> each of which is a set of <em>facts</em> (<em>ground atoms</em>). The intensional database is a set of <em>rules</em> that derive additional facts into intensional <em>relations</em> via entailment. </p>
<p>Every relation $\small r$ has a schema that describes a set of attributes $\small \lbrace \alpha_1, \ldots, \alpha_j \rbrace$, and each attribute may be labeled, and may also have a type. In general, we refer to attributes by index, a value in $\small 1, \cdots, j$.</p>
<p>Datalog <strong>Rules</strong> $\small R$ are built from a language $\small \mathcal{L}=( \mathcal{C},\mathcal{P},\mathcal{V})$ that contains the</p>
<ul>
<li>$\small \mathcal{C}$ — the finite sets of symbols for all constant values; e.g. hello, “hi” 123,</li>
<li>$\small \mathcal{P}$ — the finite set of alphanumeric character strings that begin with a lowercase character; e.g. human, size, a,</li>
<li>$\small \mathcal{V}$ — the finite set of alphanumeric character strings that begin with an uppercase character; e.g. X, A, Var.</li>
</ul>
<p>Atoms are comprised of a label, $\small p \in \mathcal{P}$, and a tuple of terms. A set of atoms form a Relation if each conforms to the schema of the relation. The form of an individual atom is as follows:</p>
<p>$$\tag{ix}\small p(t_1, \ldots, t_k)$$</p>
<p>Terms, mentioned above, may be constant values or variables such that $\small\mathcal{T}=\mathcal{C}\cup\mathcal{V}\cup\bar{t}$ where $\small\bar{t}$ represents an anonymous variable.</p>
<p>Literals within the body of a rule, represent sub-goals that are the required to be true for the rule’s head to be considered true. A literal may be an atom (termed a relational literal) or, in $\small\text{Datalog}^{\theta}$, a conditional expression (termed an arithmetic literal),</p>
<p>Any ground rule where $\small m=1$ and where $\small n=0$ is termed a Fact as it is true by nature of having an empty body, or alternatively we may consider the body be comprised of the truth value $\small\top$.</p>
<p>An atom may be also used as a Goal or Query clause in that its constant and variable terms may be used to match facts from the known facts or those that may be inferred from the set of rules introduced. A ground goal is simply determining that any fact exists that matches all the constant values provided and will return true or false. In the case that one or more variables exist a set of facts will be returned that match the expressed constants and provide the corresponding values for the variables.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="datalog-document-grammar"><a class="header" href="#datalog-document-grammar">Datalog Document Grammar</a></h1>
<p>A Datalog document is a Unicode<span class="bibref inline"><a href="vnd_datalog_text/x_references.html#UNICODE">UNICODE</a></span> character string encoded in UTF-8. Unicode code points only in the range <code>U+0</code> to <code>U+10FFFF</code> inclusive are allowed.</p>
<p><strong>White space</strong> (tab <code>U+0009</code> or space <code>U+0020</code>) is used to separate two terminals which would otherwise be (mis-)recognized as one terminal. White space is significant in the production STRING_LITERAL_QUOTE.</p>
<p><strong>Comments</strong> in a Datalog document take the form of <code>%</code> and continue to the end of line (EOL) or end of file if there is no end of line after the comment marker. </p>
<p>Comments are treated as white space.</p>
<p>The EBNF used here is defined in XML 1.0 <span class="bibref inline"><a href="vnd_datalog_text/x_references.html#EBNF-NOTATION">EBNF-NOTATION</a></span> with the addition that each rule in the grammar ends with a semicolon character <code>;</code>.</p>
<pre><code class="language-ebnf">symbol ::= expression &quot;;&quot;
</code></pre>
<h2 id="programs"><a class="header" href="#programs">Programs</a></h2>
<p>A program consists of a set of facts that comprise the extensional database, a list of rules that comprise the intensional database, and possibly a set of queries to interrogate the result of any reasoning performed over the program.</p>
<p><img src="vnd_datalog_text/images/program.png" alt="program" /></p>
<pre><code class="language-ebnf">program ::= pragma* ( fact | rule | query )* ;
</code></pre>
<p>A program consists of a single file containing facts, rules, and queries as well as any additional files referenced via <em>pragmas</em>.</p>
<h2 id="facts"><a class="header" href="#facts">Facts</a></h2>
<p>Facts <strong>must</strong> be expressed in the form of ground atoms and so they have a specific rule rather than a constrained form of the <code>atom</code> rule.</p>
<p><img src="vnd_datalog_text/images/fact.png" alt="fact" /></p>
<pre><code class="language-ebnf">fact    ::= predicate ( &quot;(&quot; constant ( &quot;,&quot; constant )* &quot;)&quot; )? &quot;.&quot; ;
</code></pre>
<p>A predicate is the identifier shared by a fact and relation.</p>
<p><img src="vnd_datalog_text/images/predicate.png" alt="predicate" /></p>
<pre><code class="language-ebnf">predicate
        ::= LC_ALPHA ( ALPHA | DIGIT | &quot;_&quot; )* ;
</code></pre>
<p><strong>Example</strong> – the following demonstrates a simple fact denoting that the constant <code>brooke</code> representing some
individual is the parent of some individual represented by the constant <code>&quot;Xerces&quot;</code>.</p>
<pre><code class="language-datalog">parent(&quot;Xerces&quot;, brooke).
</code></pre>
<h2 id="constant-values"><a class="header" href="#constant-values">Constant Values</a></h2>
<p>Constants are supported in three types, String, Numbers, and Boolean. Whereas some definitions of
Datalog introduce an additional Identifier type, ASDI treats these as <em>short strings</em> that can
safely be expressed without quotes; therefore, the values <code>xerces</code> and <code>&quot;xerces&quot;</code> are equivalent.</p>
<p><img src="vnd_datalog_text/images/constant.png" alt="constant" /></p>
<pre><code class="language-ebnf">constant
        ::= string | number | boolean ;
</code></pre>
<h3 id="strings"><a class="header" href="#strings">Strings</a></h3>
<p>Strings are described in both the identifier and quoted form in the <code>string</code> rule.</p>
<p><img src="vnd_datalog_text/images/string.png" alt="string" /></p>
<pre><code class="language-ebnf">string  ::= predicate ( &quot;:&quot; ALPHA ( ALPHA | DIGIT | &quot;_&quot; * )? )
            | DQUOTE [^\u{22}]* DQUOTE ;
</code></pre>
<h3 id="numbers"><a class="header" href="#numbers">Numbers</a></h3>
<p>Numeric values in ASDI take one of three forms, integers, decimal values, and floating point values.</p>
<blockquote>
<p>Currently, decimal types are not implemented.</p>
</blockquote>
<p><img src="vnd_datalog_text/images/number.png" alt="integer" /></p>
<pre><code class="language-ebnf">number  ::= float | decimal | integer
</code></pre>
<p>Integer values in ASDI are signed, 64-bit values (<code>i64</code>).</p>
<p><img src="vnd_datalog_text/images/integer.png" alt="integer" /></p>
<pre><code class="language-ebnf">integer ::= ( &quot;+&quot; | &quot;-&quot; )? DIGIT+
</code></pre>
<p>Decimal values in ASDI are … TBD.</p>
<p><img src="vnd_datalog_text/images/decimal.png" alt="integer" /></p>
<pre><code class="language-ebnf">decimal ::= integer &quot;.&quot; DIGIT+
</code></pre>
<p>Floating point values in ASDI are 65-bit IEEE floats (<code>f64</code>).</p>
<p><img src="vnd_datalog_text/images/float.png" alt="integer" /></p>
<pre><code class="language-ebnf">float   ::= decimal ( &quot;e&quot; | &quot;E&quot; ) integer
</code></pre>
<h3 id="booleans"><a class="header" href="#booleans">Booleans</a></h3>
<p>Boolean values may also be represented using <code>⊤</code> (down tack <code>\u{22a4}</code>) for true, and <code>⊥</code> (up tack
<code>\u{22a5}</code>) for false where this may improve readability.</p>
<p><img src="vnd_datalog_text/images/boolean.png" alt="boolean" /></p>
<pre><code class="language-ebnf">boolean ::= ( &quot;true&quot; | &quot;⊤&quot; ) | ( &quot;false&quot; | &quot;⊥&quot; ) ;
</code></pre>
<h3 id="rules"><a class="header" href="#rules">Rules</a></h3>
<p>As facts are syntactically distinct from rules in the text representation there is no need for empty
bodies – all rules <strong>must</strong> have at least one literal. Material implication may be written using
the Unicode character <code>⟵</code> (long leftwards arrow<code>\u{27f5}</code>).</p>
<p><img src="vnd_datalog_text/images/rule.png" alt="rule" /></p>
<pre><code class="language-ebnf">rule    ::= ( head | &quot;⊥&quot; )? ( &quot;:-&quot; | &quot;&lt;-&quot; | &quot;⟵&quot; ) body &quot;.&quot; ;
</code></pre>
<p>The head of a rule is a disjunction of atoms, or in the case of a constraint the head may is
optional or replaced by the value <code>&quot;⊥&quot;</code>.</p>
<p><img src="vnd_datalog_text/images/head.png" alt="head" /></p>
<pre><code class="language-ebnf">head    ::= ( atom ( ( &quot;;&quot; | &quot;|&quot; | &quot;OR&quot; | &quot;∨&quot; ) atom )* ) ;
</code></pre>
<p>The body of a rule is comprised of one, or more, literals.</p>
<p><img src="vnd_datalog_text/images/body.png" alt="body" /></p>
<pre><code class="language-ebnf">body    ::= literal ( ( &quot;,&quot; | &quot;&amp;&quot; | &quot;AND&quot; | &quot;∧&quot; ) literal )* ;
</code></pre>
<p><strong>Example</strong> – the following sets of rules are equivalent.</p>
<pre><code class="language-datalog">ancestor(X, Y) :- parent(X, Y).
ancestor(X, Y) &lt;- parent(X, Y).
ancestor(X, Y) ⟵ parent(X, Y).

movie_star(X) :- star(X)  ,  movie_cast_member(X, _, _).
movie_star(X) :- star(X)  &amp;  movie_cast_member(X, _, _).
movie_star(X) :- star(X) AND movie_cast_member(X, _, _).
movie_star(X) :- star(X)  ∧  movie_cast_member(X, _, _).
</code></pre>
<p><strong>Example</strong> – as described in the abstract syntax it is an error to use an extensional relation in the head of
a rule. The following will generate an error:</p>
<pre><code class="language-datalog">parent(&quot;Xerces&quot;, brooke).

parent(X,Y) :- father(X,Y).
</code></pre>
<p>The language feature <code>disjunction</code> corresponds to the language $\small\text{Datalog}^{\lor}$ and
allows multiple atoms to appear in the rule’s head with the semantics that these are choices. This
syntax will not be accepted unless the feature is enabled.</p>
<p><strong>Example</strong> – the following describes the rule that <em>if X is a parent then X is <strong>either</strong> a
father <strong>or</strong> mother</em>.</p>
<pre><code class="language-datalog">.feature(disjunction).

father(X) ;  mother(X) :- parent(X).
father(X) |  mother(X) :- parent(X).
father(X) OR mother(X) :- parent(X).
father(X) ⋁  mother(X) :- parent(X).
</code></pre>
<p>As the use of disjunction in this position in the head is <em>inclusive</em> it is considered that any rule as above can be transformed
into the following standard form. Clearly, in this case this is not the expected semantics which would require
an exclusive disjunction, the language $\small\text{Datalog}^{\oplus}$. Because the semantics may
cause such confusion ASDI does not do this transformation by default.</p>
<pre><code class="language-datalog">father(X) :- parent(X).
mother(X) :- parent(X).
</code></pre>
<p>The language feature <code>constraints</code> corresponds to the language $\small\text{Datalog}^{\Leftarrow}$ and
allows the specification of rules with no head. In this case the material implication symbol is
<strong>required</strong>, the falsum value is optional for readability, therefore the following rules are
equivalent.</p>
<pre><code class="language-datalog">.feature(constraints).

:- alive(X) AND dead(X).
⊥ ⟵ alive(X) ∧ dead(X).
</code></pre>
<h3 id="safety"><a class="header" href="#safety">Safety</a></h3>
<p>ASDI will disallow the addition of rules that are unsafe according to the abstract syntax. The
following are examples of unsafe rules:</p>
<ul>
<li><code>a(X) :- b(Y).</code> — because <code>X</code> appears as a distinguished variable but does not appear in a
positive relational literal, error
<a href="vnd_datalog_text/error/enum.Error.html#variant.NegativeVariablesNotAlsoPositive"><code>HeadVariablesMissingInBody</code></a>.</li>
<li><code>a(X) :- b(Y), NOT b(X).</code> — because <code>X</code> appears in a negated literal but does not appear in a
positive relational literal, error
<a href="vnd_datalog_text/error/enum.Error.html#variant.NegativeVariablesNotAlsoPositive"><code>NegativeVariablesNotAlsoPositive</code></a>.</li>
<li><code>a(X) :- b(Y), X &lt; Y.</code> — Because <code>X</code> appears in an arithmetic literal but does not appear in a
positive relational literal, error
<a href="vnd_datalog_text/error/enum.Error.html#variant.ArithmeticVariablesNotAlsoPositive"><code>ArithmeticVariablesNotAlsoPositive</code></a>.</li>
</ul>
<h2 id="atoms"><a class="header" href="#atoms">Atoms</a></h2>
<p>The text representation of an atom is a relatively simple translation from the abstract syntax
above.</p>
<p><img src="vnd_datalog_text/images/atom.png" alt="atom" /></p>
<pre><code class="language-ebnf">atom    ::= predicate &quot;(&quot; term ( &quot;,&quot; term )* &quot;)&quot; ;
</code></pre>
<p><img src="vnd_datalog_text/images/term.png" alt="term" /></p>
<pre><code class="language-ebnf">term    ::= variable | constant ;
</code></pre>
<p>Note that we explicitly separate variables into named and anonymous forms here.</p>
<p><img src="vnd_datalog_text/images/variable.png" alt="variable" /></p>
<pre><code class="language-ebnf">variable
        ::= named-variable | anon-variable ;
</code></pre>
<p><img src="vnd_datalog_text/images/named-variable.png" alt="named-variable" /></p>
<pre><code class="language-ebnf">named-variable
        ::= UC_ALPHA ( ALPHA | DIGIT | &quot;_&quot; )* ;
        
anon-variable
        ::= &quot;_&quot; ;
</code></pre>
<p><strong>Example</strong> – the following are all valid body atoms.</p>
<pre><code class="language-datalog">dead(julius_caesar).
emperor(julius_caesar, rome).
emperor(X, Y).
emperor(X, rome).
</code></pre>
<h2 id="literals"><a class="header" href="#literals">Literals</a></h2>
<p>Any valid atom is also a valid <em>positive relational</em> literal. The syntax below also allows for <em>negative</em>
literals as well as arithmetic expressions as literals. Conjunction may be written with the Unicode
character <code>∧</code> (logical and <code>\u{2227}</code>).</p>
<p><img src="vnd_datalog_text/images/literal.png" alt="literal" /></p>
<pre><code class="language-ebnf">literal ::= ( &quot;!&quot; | &quot;NOT&quot; | &quot;￢&quot; )? ( atom | comparison ) ;
</code></pre>
<p><strong>Example</strong> – the following rules are all equivalent.</p>
<pre><code class="language-datalog">ancestor(X, Y) ⟵ parent(X, Z)  ,  ancestor(Z, Y).
ancestor(X, Y) ⟵ parent(X, Z)  &amp;  ancestor(Z, Y).
ancestor(X, Y) ⟵ parent(X, Z)  ∧  ancestor(Z, Y).
ancestor(X, Y) ⟵ parent(X, Z) AND ancestor(Z, Y).
</code></pre>
<p>The language feature <code>negation</code> corresponds to the language $\small\text{Datalog}^{\lnot}$ and
allows the specification of negated literals. Negation may also be written using the Unicode
character <code>￢</code> (full-width not sign <code>\u{ffe2}</code>). The following rules are equivalent.</p>
<pre><code class="language-datalog">.feature(negation).

alive(X) :- person(X), NOT dead(X).
alive(X) ⟵ person(X) ∧ ￢dead(X).
</code></pre>
<p>The following will fail as the negated rule is not considered safe ([Error::NegativeVariablesNotAlsoPositive]).</p>
<pre><code class="language-datalog">.feature(negation).

alive(X) :- NOT dead(X).
alive(X) ⟵ ￢dead(X).
</code></pre>
<h2 id="arithmetic-literals"><a class="header" href="#arithmetic-literals">Arithmetic Literals</a></h2>
<p>The language feature <code>comparisons</code> corresponds to the language $\small\text{Datalog}^{\theta}$ and
allows the use of arithmetic literals. Comparisons take place between two literals and are
currently limited to a set of common operators. Note the addition of a string match operator, this
is similar to the Perl <code>=~</code> and requires a string value/variable on the left and a string value or
variable on the right that compiles to a valid Rust regular expression. Finally, the rule <code>named-term</code>
disallows the use of anonymous variables in arithmetic literals.</p>
<p><img src="vnd_datalog_text/images/comparison.png" alt="comparison" /></p>
<pre><code class="language-ebnf">comparison
        ::= ( named-variable | constant ) operator ( named-variable | constant ) ;
</code></pre>
<p><img src="vnd_datalog_text/images/operator.png" alt="operator" /></p>
<pre><code class="language-ebnf">operator
        ::= &quot;=&quot;
            | (&quot;!=&quot; | &quot;/=&quot; | &quot;≠&quot;)
            | &quot;&lt;&quot;
            | (&quot;&lt;=&quot; | &quot;≤&quot;)
            | &quot;&gt;&quot;
            | (&quot;&gt;=&quot; | &quot;≥&quot;)
            | (&quot;*=&quot; | &quot;≛&quot; | &quot;MATCHES&quot;) ;
</code></pre>
<p>The Unicode characters <code>≠</code> (not equal to <code>\u{2260}</code>), <code>≤</code> (less-than or equal to <code>\u{2264}</code>),
<code>≥</code> (greater-than or equal to <code>\u{2265}</code>, and star equals <code>\u{e2899b}</code>) may be substituted for the
common arithmetic and string operators.</p>
<p>All arithmetic operations <strong>must</strong> be between terms of the some type, such that the property
<em>compatible</em> introduce above is defined as:</p>
<p>$$\tag{xvi}\small compatible(\tau_{lhs}, \tau_{rhs}, \theta) \leftarrow \tau_{lhs} = \tau_{rhs}$$</p>
<p>Additionally, some operators are not present for all types, as shown in the table below.</p>
<table><thead><tr><th>Type</th><th><code>=</code>, <code>≠</code></th><th><code>&lt;</code>, <code>≤</code>, <code>&gt;</code>, <code>≥</code></th><th><code>≛</code></th></tr></thead><tbody>
<tr><td>String</td><td>Yes</td><td>Yes - lexical</td><td>Yes</td></tr>
<tr><td>Integer</td><td>Yes</td><td>Yes</td><td>No</td></tr>
<tr><td>Boolean</td><td>Yes</td><td>No</td><td>No</td></tr>
</tbody></table>
<p><strong>Example</strong> – the following is an example using arithmetic literals and the <em>car</em> relation.</p>
<pre><code class="language-datalog">.feature(comparisons).
.assert car(make: string, model: string, age: integer).

antique(X, Y) :- car(X, Y, _) AND X *= &quot;[dD]uesenberg&quot;.
antique(X, Y) :- car(X, Y, _) AND Y = &quot;model t&quot;.
antique(X, Y) :- car(X, Y, Z) AND Z &gt; 50.
</code></pre>
<h2 id="queries"><a class="header" href="#queries">Queries</a></h2>
<p>A query is simply an atom, but one identified to the system as a goal with either the prefix <code>?-</code>
or the suffix <code>?</code>.</p>
<p><img src="vnd_datalog_text/images/query.png" alt="query" /></p>
<pre><code class="language-ebnf">query   ::= ( &quot;?-&quot; atom &quot;.&quot; ) | ( atom &quot;?&quot; ) ;
</code></pre>
<p><strong>Example</strong> – the following queries are equivalent and will return the value of the variable <code>X</code> for any facts in
the <em>ancestor</em> relationship where the first attribute is the string value <code>&quot;xerces&quot;</code>.</p>
<pre><code class="language-datalog">?- ancestor(xerces, X).
ancestor(xerces, X)?
</code></pre>
<p>When the value <code>_</code> is used in a query it denotes an attribute of the relation that has no meaning
in either the query or the response. For example, in the following query we ask for all values of
the <em>model</em> attribute in the <em>car</em> relation where the <em>make</em> is “ford”, and ignore the age entirely.</p>
<pre><code class="language-datalog">.assert car(make: string, model: string, age: integer).

car(&quot;ford&quot;, X, _)?
</code></pre>
<p>The results of this query would not include the age column:</p>
<pre><code class="language-text">+------------+
| model      |
+============+
| edge       |
+------------+
| escort     |
+------------+
| fiesta     |
+------------+
| focus      |
+------------+
| fusion     |
+------------+
| mustang    |
+------------+
     ...
</code></pre>
<h2 id="pragmas"><a class="header" href="#pragmas">Pragmas</a></h2>
<p>Pragmas are declarative statements meant for the parser and runtime tooling, they do not affect
the meaning of the program itself.</p>
<p><img src="vnd_datalog_text/images/pragma.png" alt="pragma" /></p>
<pre><code class="language-ebnf">pragma  ::= &quot;.&quot; ( feature | assert | infer | fd | input | output ) &quot;.&quot; ;
</code></pre>
<h3 id="pragma-feature"><a class="header" href="#pragma-feature">pragma feature</a></h3>
<p>The <code>feature</code> pragma determines which Datalog language is in use. Use of syntax not supported by the
selected language feature will result in errors.</p>
<p><img src="vnd_datalog_text/images/feature.png" alt="feature" /></p>
<pre><code class="language-ebnf">feature ::= &quot;feature&quot; &quot;(&quot; feature-id ( &quot;,&quot; feature-id )* &quot;)&quot; ;
</code></pre>
<p><img src="vnd_datalog_text/images/feature-id.png" alt="feature-id" /></p>
<pre><code class="language-ebnf">feature-id
        ::= &quot;comparisons&quot;
        | &quot;constraints&quot;
        | &quot;disjunction&quot;
        | &quot;negation&quot;
        | &quot;functional_dependencies&quot;
</code></pre>
<p><strong>Example</strong></p>
<pre><code class="language-datalog">.feature(negation).
.feature(comparisons, disjunction).
</code></pre>
<h3 id="pragma-assert"><a class="header" href="#pragma-assert">pragma assert</a></h3>
<p>The <code>assert</code> pragma describes a new relation in the extensional database. The parser can determine
the schema for facts from their types in the database. The use of this pragma is therefore optional,
but recommended.</p>
<p><img src="vnd_datalog_text/images/assert.png" alt="assert" /></p>
<pre><code class="language-ebnf">assert  ::= &quot;assert&quot; predicate &quot;(&quot; attribute-decl ( &quot;,&quot; attribute-decl )* &quot;)&quot; ;
</code></pre>
<p><img src="vnd_datalog_text/images/attribute-decl.png" alt="attribute-decl" /></p>
<pre><code class="language-ebnf">attribute-decl
        ::= ( predicate &quot;:&quot; )? ( &quot;boolean&quot; | &quot;integer&quot; | &quot;string&quot; ) ;
</code></pre>
<p><strong>Example</strong></p>
<pre><code class="language-datalog">.assert human(name: string).
</code></pre>
<h3 id="pragma-infer"><a class="header" href="#pragma-infer">pragma infer</a></h3>
<p>The <code>infer</code> pragma describes a new relation in the intensional database. Typically the parser
can determine the schema for relational literals from their context, The use of this pragma
is therefore optional, but recommended. The alternate form is more explicit in that it defines
an intensional relation in terms of a previously defined extensional relation.</p>
<p><img src="vnd_datalog_text/images/infer.png" alt="infer" /></p>
<pre><code class="language-ebnf">infer   ::= &quot;infer&quot;
            ( predicate &quot;(&quot; attribute-decl ( &quot;,&quot; attribute-decl )* &quot;)&quot; )
            | &quot;from&quot; predicate ;
</code></pre>
<p><strong>Example</strong></p>
<pre><code class="language-datalog">.infer mortal(name: string).
</code></pre>
<p>Alternatively the short-cut form is often more convenient.</p>
<pre><code class="language-datalog">.assert human(name: string).
.infer mortal from human.
</code></pre>
<h3 id="pragma-fd"><a class="header" href="#pragma-fd">pragma fd</a></h3>
<p>The <code>fd</code> pragma, short for <em>functional dependency</em>, introduces a relationship between one or more attributes on the
left-hand (determinant) side and one or more attributes on the right-hand (dependent) side. This relationship denotes
that for a relationship $\small R$ with attributes $\small a_1, \cdots, a_n$, every valid combination of determinant
values uniquely determines the value of the dependent values.</p>
<p>Note that this pragma is only valid if the corresponding language feature is enabled.</p>
<p><img src="vnd_datalog_text/images/fd.png" alt="input" /></p>
<pre><code class="language-ebnf">fd      ::= ( &quot;fd&quot; | &quot;functional_dependency&quot; ) 
            predicate &quot;:&quot;
            attribute-index-list ( &quot;--&gt;&quot; | &quot;⟶&quot; ) attribute-index-list
</code></pre>
<p><img src="vnd_datalog_text/images/attribute-index-list.png" alt="input" /></p>
<pre><code class="language-ebnf">attribute-index-list
        ::= attribute-index ( &quot;,&quot; attribute-index )*
</code></pre>
<p>An attribute index is <em>either</em> an attribute label, if one has been declared for the relation, or an integer $\small i \in [1,|schema(R)|]$.</p>
<p><img src="vnd_datalog_text/images/attribute-index.png" alt="input" /></p>
<pre><code class="language-ebnf">attribute-index
        ::= integer | predicate
</code></pre>
<p><strong>Constraints</strong> – given the notational form $\small R: \alpha \rightarrow \Beta$;</p>
<ol>
<li>the initial predicate <strong>must</strong> be the label of an extensional relation:
$$\small R \in D_I \land label(R)$$</li>
<li>the set of attribute identifiers comprising the set $\small \alpha$ <strong>must</strong> be in $\small R$:
$$\small \forall a \in \alpha (a \in schema(R))$$</li>
<li>the set of attribute identifiers comprising the set $\small \Beta$ <strong>must</strong> be in $\small R$:
$$\small \forall a \in \Beta (a \in schema(R))$$</li>
<li>the same attribute identifier <strong>must not</strong> appear in both determinant and dependent:
$$\small \alpha \cap \Beta = \emptyset$$</li>
</ol>
<p><strong>Example</strong> – given the extensional relation <em>employee</em> the two functional dependencies in the
following are equivalent. Note that the implementation will ignore such duplicate declarations.</p>
<pre><code class="language-datalog">.feature(functional_dependencies).
.assert employee(id:integer, name:string).

.fd employee: id --&gt; name.
.fd employee: 1 ⟶ 2.
</code></pre>
<h3 id="pragma-input"><a class="header" href="#pragma-input">pragma input</a></h3>
<p>The <code>input</code> pragma instructs the parser to load facts for the named extensional relation from an
external file. This pragma <strong>requires</strong> that the relation be previously defined via the <code>assert</code>
pragma.</p>
<p><img src="vnd_datalog_text/images/input.png" alt="input" /></p>
<pre><code class="language-ebnf">input   ::= &quot;input&quot; io-details &quot;.&quot;
</code></pre>
<p><img src="vnd_datalog_text/images/io-details.png" alt="io-details" /></p>
<pre><code class="language-ebnf">io-details
        ::= &quot;(&quot; predicate &quot;,&quot; quoted-string ( &quot;,&quot; quoted-string )? &quot;)&quot; ;
</code></pre>
<p><strong>Example</strong></p>
<pre><code class="language-datalog">.assert human(name: string).
.input(human, &quot;data/humans.csv&quot;, &quot;csv&quot;).
</code></pre>
<h3 id="pragma-output"><a class="header" href="#pragma-output">pragma output</a></h3>
<p>The <code>output</code> pragma instructs the parser to write facts from the named intensional relation to an
external file. This pragma <strong>requires</strong> that the relation be previously defined via the <code>infer</code>
pragma.</p>
<p><img src="vnd_datalog_text/images/output.png" alt="output" /></p>
<pre><code class="language-ebnf">output  ::= &quot;output&quot; io-details &quot;.&quot; ;
</code></pre>
<p><strong>Example</strong></p>
<pre><code class="language-datalog">.infer mortal(name: string).
.output(mortal, &quot;data/mortals.txt&quot;).
</code></pre>
<h2 id="comments"><a class="header" href="#comments">Comments</a></h2>
<p>Comments in Datalog are either 1) the <code>%</code> character and continue to the end of the line, or
2) C-style with <code>/*</code> to start and <code>*/</code> to end. These correspond to the same rules as Prolog.</p>
<p><img src="vnd_datalog_text/images/comment.png" alt="comment" /></p>
<pre><code class="language-ebnf">comment ::= &quot;%&quot; [^\r\n]* EOL
            | &quot;/&quot; &quot;*&quot; ( [^\*] | &quot;*&quot;+ [^\*\/] )* &quot;*&quot;+ &quot;/&quot; ;
</code></pre>
<p><strong>Example</strong></p>
<pre><code class="language-datalog">% Here's a comment
?- ancestor(xerces, X). % and another
?- ancestor(brooke /* and one inline */, X). % and another
</code></pre>
<h2 id="terminal-lexical-symbols"><a class="header" href="#terminal-lexical-symbols">Terminal (Lexical) Symbols</a></h2>
<p>The following are lexical rules that can be assumed by the rules above.</p>
<pre><code class="language-ebnf">EOL     ::= &quot;\n&quot; | &quot;\r\n&quot; | &quot;\r&quot; ;

WHITESPACE
        ::= &quot; &quot; | &quot;\t&quot; | EOL ;
        
DQUOTE
        ::= '&quot;' ;
        
LC_ALPHA
        ::= ? corresponds to the Unicode category 'Ll' (letter, lower case) ? ;
        
UC_ALPHA
        ::= ? corresponds to the Unicode category 'Lu' (letter, upper case) ? ;
        
ALPHA   ::= LC_ALPHA | UC_ALPHA ;

DIGIT   ::= ? corresponds to the Unicode category 'Nd' (decimal number) ? ;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="dataset-processing"><a class="header" href="#dataset-processing">Dataset Processing</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="appendix-ebnf"><a class="header" href="#appendix-ebnf">Appendix: EBNF</a></h1>
<p>The EBNF used here is defined in XML 1.0 <span class="bibref inline"><a href="vnd_datalog_text/x_references.html#EBNF-NOTATION">EBNF-NOTATION</a></span> with the addition that each rule in the grammar ends with a semicolon character <code>;</code>.</p>
<pre><code class="language-ebnf">program ::= processing-instruction* ( fact | rule | query )* ;

/* ************************************************************************* */

fact    ::= predicate ( &quot;(&quot; constant ( &quot;,&quot; constant )* &quot;)&quot; )? &quot;.&quot; ;

predicate
        ::= LC_ALPHA ( ALPHA | DIGIT | &quot;_&quot; )* ;

/* ************************************************************************* */

constant
        ::= string | number | boolean ;

string  ::= predicate ( &quot;:&quot; ALPHA ( ALPHA | DIGIT | &quot;_&quot; * )? )
            | DQUOTE [^#x22]* DQUOTE ;

number  ::= float | decimal | integer ;

integer ::= ( &quot;+&quot; | &quot;-&quot; )? DIGIT+ ;

decimal ::= integer &quot;.&quot; DIGIT+ ;

float   ::= decimal ( &quot;e&quot; | &quot;E&quot; ) integer ;

boolean ::= ( &quot;true&quot; | &quot;⊤&quot; ) | ( &quot;false&quot; | &quot;⊥&quot; ) ;

/* ************************************************************************* */

rule    ::= ( head | &quot;⊥&quot; )? ( &quot;:-&quot; | &quot;&lt;-&quot; | &quot;⟵&quot; ) body &quot;.&quot; ;

head    ::= ( atom ( ( &quot;;&quot; | &quot;|&quot; | &quot;OR&quot; | &quot;∨&quot; ) atom )* ) ;

body    ::= literal ( ( &quot;,&quot; | &quot;&amp;&quot; | &quot;AND&quot; | &quot;∧&quot; ) literal )* ;


/* ************************************************************************* */

atom    ::= predicate &quot;(&quot; term ( &quot;,&quot; term )* &quot;)&quot; ;

term    ::= variable | constant ;

variable
        ::= named-variable | anon-variable ;

named-variable
        ::= UC_ALPHA ( ALPHA | DIGIT | &quot;_&quot; )* ;

anon-variable
        ::= &quot;_&quot; ;

/* ************************************************************************* */

literal ::= ( &quot;!&quot; | &quot;NOT&quot; | &quot;￢&quot; )? ( atom | comparison ) ;

/* ************************************************************************* */

comparison
        ::= operand operator operand ;

operand ::= ( named-variable | constant ) ;

operator
        ::= &quot;=&quot;
            | (&quot;!=&quot; | &quot;/=&quot; | &quot;≠&quot;)
            | &quot;&lt;&quot;
            | (&quot;&lt;=&quot; | &quot;≤&quot;)
            | &quot;&gt;&quot;
            | (&quot;&gt;=&quot; | &quot;≥&quot;)
            | (&quot;*=&quot; | &quot;≛&quot; | &quot;MATCHES&quot;) ;

/* ************************************************************************* */

query   ::= ( &quot;?-&quot; atom &quot;.&quot; ) | ( atom &quot;?&quot; ) ;

/* ************************************************************************* */

processing-instruction
        ::= &quot;.&quot;
            ( pi-feature | pi-assert | pi-infer | pi-fd | pi-input | pi-output )
            &quot;.&quot; ;

pi-feature
        ::= &quot;feature&quot; &quot;(&quot; feature-id ( &quot;,&quot; feature-id )* &quot;)&quot; ;

feature-id
        ::= &quot;comparisons&quot;
        | &quot;constraints&quot;
        | &quot;disjunction&quot;
        | &quot;negation&quot;
        | &quot;functional_dependencies&quot; ;

pi-assert
        ::= &quot;assert&quot; predicate &quot;(&quot; attribute-decl ( &quot;,&quot; attribute-decl )* &quot;)&quot; ;

attribute-decl
        ::= ( predicate &quot;:&quot; )? ( &quot;boolean&quot; | &quot;integer&quot; | &quot;string&quot; ) ;

pi-infer
        ::= &quot;infer&quot;
            ( predicate &quot;(&quot; attribute-decl ( &quot;,&quot; attribute-decl )* &quot;)&quot;
            | &quot;from&quot; predicate ) &quot;.&quot; ;

pi-fd   ::= ( &quot;fd&quot; | &quot;functional_dependency&quot; )
            predicate &quot;:&quot;
            attribute-index-list ( &quot;--&gt;&quot; | &quot;⟶&quot; ) attribute-index-list ;

attribute-index-list
        ::= attribute-index ( &quot;,&quot; attribute-index )* ;

attribute-index
        ::= integer | predicate ;

pi-input
        ::= &quot;input&quot; io-details ;

io-details
        ::= &quot;(&quot; predicate &quot;,&quot; quoted-string ( &quot;,&quot; quoted-string )? &quot;)&quot; ;

pi-output
        ::= &quot;output&quot; io-details ;

/* ************************************************************************* */

comment ::= &quot;%&quot; [^\r\n]* EOL
            | '/*' ( [^*] | '*'+ [^*/] )* '*'* '*/' ;

/* ************************************************************************* */

EOL     ::= &quot;\n&quot; | &quot;\\r\\n&quot; | &quot;\r&quot; ;

WHITESPACE
        ::= &quot; &quot; | &quot;\t&quot; | EOL ;

DQUOTE  ::= #x22 ;

LC_ALPHA
        ::= ? corresponds to the Unicode category 'Ll' ? ;

UC_ALPHA
        ::= ? corresponds to the Unicode category 'Lu' ? ;

ALPHA   ::= LC_ALPHA | UC_ALPHA ;

DIGIT   ::= ? corresponds to the Unicode category 'Nd' (decimal number) ? ;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="appendix-international-considerations"><a class="header" href="#appendix-international-considerations">Appendix: International Considerations</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="appendix-iana-considerations"><a class="header" href="#appendix-iana-considerations">Appendix: IANA Considerations</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="appendix-references"><a class="header" href="#appendix-references">Appendix: References</a></h1>
<div class="biblio">
<ol>
<li>
<p><span class="bibkey" id="EBNF-NOTATION">EBNF-NOTATION</span>Tim Bray; Jean Paoli; C. M. Sperberg-McQueen; Eve Maler; François Yergeau. <em><a href="http://www.w3.org/TR/REC-xml/#sec-notation">EBNF Notation</a></em> 26 November 2008. W3C Recommendation. URL: <a href="http://www.w3.org/TR/REC-xml/#sec-notation">http://www.w3.org/TR/REC-xml/#sec-notation</a></p>
</li>
<li>
<p><span class="bibkey" id="RFC2119">RFC2119</span>S. Bradner. <em><a href="https://tools.ietf.org/html/rfc2119">Key words for use in RFCs to Indicate Requirement Levels</a></em>. March 1997. IETF. Best Current Practice. URL: <a href="https://tools.ietf.org/html/rfc2119">https://tools.ietf.org/html/rfc2119</a></p>
</li>
<li>
<p><span class="bibkey" id="RFC8174">RFC8174</span>B. Leiba. <em><a href="https://tools.ietf.org/html/rfc8174">Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words</a></em>. May 2017. IETF. Best Current Practice. URL: <a href="https://tools.ietf.org/html/rfc8174">https://tools.ietf.org/html/rfc8174</a></p>
</li>
<li>
<p><span class="bibkey" id="UNICODE">UNICODE</span><em><a href="http://www.unicode.org/versions/latest/">The Unicode Standard</a></em>. URL: <a href="http://www.unicode.org/versions/latest/">http://www.unicode.org/versions/latest/</a></p>
</li>
</ol>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="datalog-text-representation--errata"><a class="header" href="#datalog-text-representation--errata">Datalog Text Representation – Errata</a></h1>
<h2 id="version-xx-march-2022"><a class="header" href="#version-xx-march-2022">Version: XX March 2022.</a></h2>
<p>None.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="datalog-text-representation--translations"><a class="header" href="#datalog-text-representation--translations">Datalog Text Representation – Translations</a></h1>
<h2 id="version-xx-march-2022-1"><a class="header" href="#version-xx-march-2022-1">Version: XX March 2022.</a></h2>
<p>None.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript" src="datalog.js"></script>
        <script type="text/javascript" src="specs.js"></script>
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
    </body>
</html>
