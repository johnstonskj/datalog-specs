program ::= processing-instruction* ( fact | rule | query )* ;

/* ************************************************************************* */

fact    ::= predicate ( "(" constant ( "," constant )* ")" )? "." ;

predicate
        ::= LC_ALPHA ( ALPHA | DIGIT | "_" )* ;

/* ************************************************************************* */

constant
        ::= string | number | boolean ;

string  ::= identifier-string | literal-string ;

identifier-string
        ::= predicate ( ":" ALPHA ( ALPHA | DIGIT | "_" )* )? ;

literal-string
        ::= DQUOTE ( string-escape | [^#x22] )* DQUOTE ;

string-escape
        ::= "\\" ( DQUOTE | [tnr] )
        | "\u{" HEXDIGIT HEXDIGIT HEXDIGIT HEXDIGIT
              ( HEXDIGIT HEXDIGIT HEXDIGIT HEXDIGIT )? "}" ;

number  ::= float | decimal | integer ;

integer ::= ( "+" | "-" )? DIGIT+ ;

decimal ::= integer "." DIGIT+ ;

float   ::= decimal ( "e" | "E" ) integer ;

boolean ::= ( "true" | "⊤" ) | ( "false" | "⊥" ) ;

/* ************************************************************************* */

rule    ::= ( head | "⊥" )? ( ":-" | "<-" | "⟵" ) body "." ;

head    ::= ( atom ( ( ";" | "|" | "OR" | "∨" ) atom )* ) ;

body    ::= literal ( ( "," | "&" | "AND" | "∧" ) literal )* ;

/* ************************************************************************* */

atom    ::= predicate "(" term ( "," term )* ")" ;

term    ::= variable | constant ;

variable
        ::= named-variable | anon-variable ;

named-variable
        ::= UC_ALPHA ( ALPHA | DIGIT | "_" )* ;

anon-variable
        ::= "_" ;

/* ************************************************************************* */

literal ::= ( "!" | "NOT" | "￢" )?
            ( relational-literal | arithmetic-literal ) ;

/* ************************************************************************* */

relational-literal
        ::= atom ;

arithmetic-literal
        ::= operand operator operand ;

operand ::= ( named-variable | constant ) ;

operator
        ::= "="
            | ("!=" | "/=" | "≠")
            | "<"
            | ("<=" | "≤")
            | ">"
            | (">=" | "≥")
            | ("*=" | "≛" | "MATCHES") ;

/* ************************************************************************* */

query   ::= ( "?-" atom "." )
        |   ( atom "?" ) ;

/* ************************************************************************* */

processing-instruction
        ::= "."
            ( pi-feature
            | pi-assert
            | pi-infer
            | pi-fd
            | pi-input
            | pi-output
            | pi-pragma )
            "." ;

pi-feature
        ::= "feature" "(" feature-id ( "," feature-id )* ")" ;

feature-id
        ::= "arithmetic_literals"
        |   "constraints"
        |   "disjunction"
        |   "negation"
        |   "functional_dependencies" ;

pi-assert
        ::= "assert" relation-decl ;

relation-decl
        ::= predicate "(" attribute-decl ( "," attribute-decl )* ")" ;

attribute-decl
        ::= ( predicate ":" )?
            ( "boolean" | "float" | "decimal" | "integer" | "string" ) ;

pi-infer
        ::= "infer" ( relation-decl | "from" predicate ) ;

pi-fd   ::= ( "fd" | "functional_dependency" )
            predicate ":"
            attribute-index-list ( "-->" | "⟶" ) attribute-index-list ;

attribute-index-list
        ::= attribute-index ( "," attribute-index )* ;

attribute-index
        ::= integer | predicate ;

pi-input
        ::= "input" io-details ;

io-details
        ::= "(" predicate "," quoted-string
                ( "," format-spec )?
            ")" ;

format-spec
        ::= quoted-string ( "," assign-list )? ;

assign-list
        ::= assignment ( "," assignment )* ;

assignment
        ::= predicate "=" constant ;

pi-output
        ::= "output" io-details ;

pi-pragma
        ::= "pragma" predicate ( "(" assignment-list ")" )? ;

/* ************************************************************************* */

comment ::= line-comment | block-comment ;

line-comment
        ::= "%" [^\r\n]* EOL ;

block-comment
        ::= '/*' ( [^*] | '*'+ [^*/] )* '*'* '*/' ;

/* ************************************************************************* */

EOL     ::= "\n" | "\r" "\n"? ;

SPACE_SEP
        ::= ? corresponds to the Unicode category 'Zs' ? ;

WHITESPACE
        ::= SPACE_SEP | "\t" | EOL ;

DQUOTE  ::= #x22 ;

LC_ALPHA
        ::= ? corresponds to the Unicode category 'Ll' ? ;

UC_ALPHA
        ::= ? corresponds to the Unicode category 'Lu' ? ;

TC_ALPHA
        ::= ? corresponds to the Unicode category 'Lt' ? ;

ALPHA   ::= LC_ALPHA | UC_ALPHA | TC_ALPHA ;

DIGIT   ::= ? corresponds to the Unicode category 'Nd' (decimal number) ? ;

HEXDIGIT
        ::= [0-9a-fA-F] ;